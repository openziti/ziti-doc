{
  "api/csharp/NetFoundry.ZitiIdentity.html": {
    "href": "api/csharp/NetFoundry.ZitiIdentity.html",
    "title": "Class ZitiIdentity | NetFoundry Ziti",
    "keywords": "Class ZitiIdentity Represents an enrolled identity Inheritance System.Object ZitiIdentity Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiIdentity : object Constructors | Improve this Doc ZitiIdentity(String) Creates a new ZitiIdentity using the provided path. The path must point at a file is the result of the enrollment process. Declaration public ZitiIdentity(string path) Parameters Type Name Description System.String path The path to the enrolled Ziti identity | Improve this Doc ZitiIdentity(String, Int32) Creates a new ZitiIdentity with the provided timeout (ms) using the provided path. The path must point at a file is the result of the enrollment process. Declaration public ZitiIdentity(string path, int timeOutInMillis) Parameters Type Name Description System.String path The path to the enrolled ziti identity System.Int32 timeOutInMillis timeout in milliseconds Properties | Improve this Doc PathToConfigFile The path to the enrolled identity Declaration public string PathToConfigFile { get; } Property Value Type Description System.String Methods | Improve this Doc Dump() Dumps debug information to standard out. Only used when debugging Declaration public void Dump() | Improve this Doc InitializeAndRun() Initializes this identity with the NetFoundry network Declaration public void InitializeAndRun() | Improve this Doc NewConnection(String) Creates a new ZitiConnection for this identity Declaration public ZitiConnection NewConnection(string serviceName) Parameters Type Name Description System.String serviceName The service name to create a ZitiConnection for Returns Type Description ZitiConnection A ZitiConnection that is ready to be Dialed or converted to a stream via AsStream() Exceptions Type Condition ZitiException Thrown when the serviceName provided does not exist | Improve this Doc ServiceAvailable(String) Determines if the provided serviceName is available for this identity Declaration public bool ServiceAvailable(string serviceName) Parameters Type Name Description System.String serviceName The service name to verify Returns Type Description System.Boolean If the service exists - true, false if not | Improve this Doc Shutdown() instructs this identity to disconnect from the NetFoundry network Declaration public void Shutdown()"
  },
  "api/rest/create-service-rest.html": {
    "href": "api/rest/create-service-rest.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "ziti/install/edge-router.html": {
    "href": "ziti/install/edge-router.html",
    "title": "| NetFoundry Ziti",
    "keywords": "UNUSED # Edge Router The Edge Router is responsible for the"
  },
  "api/csharp/NetFoundry.ZitiConnection.OnDataReceived.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnDataReceived.html",
    "title": "Delegate ZitiConnection.OnDataReceived | NetFoundry Ziti",
    "keywords": "Delegate ZitiConnection.OnDataReceived A delegate that represents the work to be done when data is recieved over the Ziti network. Only invoked after a successful Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) . Each time data is received it is important to verify the status is still OK Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnDataReceived(ZitiStatus status, byte[] data, int count); Parameters Type Name Description ZitiStatus status The ZitiStatus representing the outcome of the write operation. System.Byte [] data A buffer representing the data that was received over the Ziti network. Data will always start at postiion 0. System.Int32 count The number of bytes received in this interation. Data will always start at postiion 0."
  },
  "ziti/identities/overview.html": {
    "href": "ziti/identities/overview.html",
    "title": "Ziti Identities | NetFoundry Ziti",
    "keywords": "Ziti Identities Ziti is built on the foundation of zero-trust. A solid pillar of that foundation requires that all connections in a Ziti-enabled network are authenticated. Identities are the basis for Ziti authentication. All devices connecting to a Ziti network will have an Identity which is presented at the time of a connection being established by both the device initiating the connection and the device receiving the incoming connection. Ziti implements mutual TLS in order to authenticate both sides of a connection. Conceptually an identity can be thought of as congruent to a user account. Identities are logical entities stored inside the Ziti Controller which map an X509 certifcate to a particular named identity. Identities exist not only to authenticate connections but are also used to authorize identities within Ziti. See AppWANs for more information on authoriziation of identities. 3rd Party Certificates The certificate a Ziti Edge client presents can be generated by the Ziti Controller using the configured PKI or this certificate can come from a existing PKI not controlled by the Ziti Controller. Certificates which are not created by the Ziti Controller are referred to as \"3rd Party\" because from the perspective of the Ziti Controller the certificates are not from the configured PKI. Creating an Identity The mechanism for creating identities is influenced by how your Ziti network is setup, specifically how the PKI is established. Identities are itegrally linked to the PKI configured in a given Ziti network and directly affects how identites are created. There are generally three groups of identities which can be created: One Time Token (ott) identites using the configured PKI One Time Token (ott) identites using a 3rd Party CA 3rd Party auto-enrolled identities Choosing an Identity Type Choosing which type of identity you are creating comes down to whether you are using a 3rd Party CA or not. If the network does not have a 3rd Party Certificate configured the only option is to use the One Time Token identity. If one or more 3rd Party CA is installed you will need to understand the intention of each 3rd Party certificate. Each of the types of identities are secure it just depends on your actual network setup as to which type to choose. If you don't know - just use the one time token identity. The identity can always be recreated at a later date and replaced if necessary. One Time Token (OTT) One time token identities are the type of identities available to all Ziti networks. A one time token identity will have a token generated at the time of the identity's creation. This token is then submitted at some point in the future as part of the enrollment process. Once an identity is successfully enrolled - the one time token is no longer valid and cannot be used to enroll the same identity again. One time tokens are delivered from the Ziti Controller as a jwt and the token expires 24 hours after the identity is created. The token is downloadable via the basic UI provided in the Ziti Edge - Developer Edition . After you create a user you can go to the Identities page and click the icon that looks like a certificate to download the .jwt file. You can also create a one time token identity using the ziti cli tool available on the path of the Ziti Edge - Developer Edition . This command will create a new identity and output the jwt to the selected path. You can then transfer the .jwt file to its intended destination. #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt 3rd Party CA - Overview The Ziti Controller is capable of using an existing PKI for authentication and authorization rather than to PKI configured in the Ziti Controller. Certificates that are not controlled by the Ziti Controller are referred to as \"3rd party\". If you have an existing PKI setup you wish to reuse or if you are just interested in learning how to use a 3rd Party CA this section is for you. Note Reusing a PKI is not a simple topic and managing and maintaining a PKI is out of the scope of this guide. A 3rd Party CA will need to be created and the public certificate uploaded into the Ziti Controller. After using an existing PKI to reuse/generate a certificate, the Ziti Controller will be to create identities which will be expected to present a certificate during the connection process that is valid per the provided certificate. Adding a 3rd Party CA to the Ziti Controller Adding a certifate to the Ziti Controller is easy using the Ziti Console provided in the Ziti Edge - Developer Edition . New CA via UI New CA via REST On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format body: { \"name\": \"${string}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${string}\" } 3rd Party CA - One Time Token 3rd Party CA OTT enrollment is closely related to OTT Enrollment . The main difference is the utilization of a 3rd party CA certificate rather than the configured Ziti Edge CA and PKI. In this method, the system does not have access to the 3rd party CA private key and thus cannot provide CSR fulfillment capabilities. Instead it is assumed that the enrolling device has a separate process to acquire signed certificates. Rather than submitting a CSR the client uses an already acquired signed certificate as its client certificate for the enrollment request. The client certificate is validated against the CA certificate tied to the one time token. Similar to the OTT Enrollment process, identities must be provisioned ahead of enrollment in order to generate one time token required and to creat the jwt that can be delivered to enrolling devices. This means that the provisioning of the Ziti Edge identities and the client certificates must be coordinated. Identities can be enrolled with a one time token flow similar to the one time token flow . 3rd Party CA - Auto Enrolled CA Auto Enrollment is useful in situations where devices are provisioned with certificates en-mass that need to be able to register as identities within Ziti Edge. This enrollment method allows for device provisioning processes to skip the manual configuration of Ziti Edge and instead allow clients to present a signed client certificate to generate an identity during the enrollment process. The identity will grant the client access to authenticate only - any authorization will need to be done after the device identities have been created. A certificate can only be used for one identity. The Ziti Edge system does not allow the same certificate to be used for multiple identities. An enrollment request is comprised of a special enrollment URL used to perform an HTTP POST request using the signed client certificate as the TLS client certificate and an optional JSON payload that allows the client to specify the devices display name and internal username. See enrollment for more details on enrolling. New Identity via UI New Identity via UI On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt Enrolling an Identity All connections made to the Ziti network leverage mutual TLS which means every client needs a valid X509 certificate which it will present to the Ziti network during the connection process. The process of obtaining a key/certificate pair and presenting it securely to the Ziti Controller is called \"Enrollment\". Overview All identities need to be enrolled with the Ziti Controller so the Ziti Controller can authenticate the incoming connection. This process is slightly different for each type of identity. NetFoundry has created a tool to aid the enrollment process named ziti-enroller . It is recommended that you use ziti-enroller to complete the enrollment as the process itself complex. Enrollers are available here: Windows MacOS Linux One Time Token Enrollment - Internal PKI Perhaps the easiest path to an enrolled identity is by using the one time token enrollment flow. This flow leverages the PKI configured in the Ziti Controller. Using the one time token flow - the ziti-enroller will generate a private key and a certificate signing request for the Ziti Controller to sign. Follow these steps to enroll a one time token identity: create the Identity download or copy the jwt - this file contains the single use token run the ziti-enroller for your given operating system: ziti-enroller --jwt ${jwt_file} Important The output from the ziti-enroller is a json file which must be kept secure. This file contains within it the private key used to generate a certificate request which was sent to the Ziti Controller and signed. This file should not be transferred or shared and should not be moved from the machine unless you are confident you understand the risks involved in doing so. 3rd Party CA - One Time Token This process is similar to the One Time Token flow from above. This flow expects that a private key and certificate have already been created on the machine that is about to enroll and that the certificate presented is valid to a CA already uploaded to the Ziti Controller. Follow these steps to enroll a 3rd Pary CA - one time token identity: create the Identity download or copy the jwt - this file contains the single use token run the ziti-enroller for your given operating system. Notice you can provide the name of the identity : ziti-enroller -v --jwt ${jwt_file} --cert ${identity_path_to_cert} --key ${identity_path_to_key} --idname ${identity_name} 3rd Party CA - Auto This enrollment process is almost entirely automated. With \"auto\" no identity needs to exist prior to enrollment. The act of enrolling the identity actually creates the identity. Like \"3rd Party CA - One Time Token\" - this flow expects that a private key and certificate have already been created on the machine that is about to enroll and that the certificate presented is valid to a CA already uploaded to the Ziti Controller. This flow also requires that a jwt specifically created for enrollment be downloaded from the CA and the CA uploaded needs to be valid for isAutoCaEnrollmentEnabled. You can get the .jwt by downloading the file from: ${controller_uri}/cas/${ca_id}/jwt"
  },
  "ziti/install/overview.html": {
    "href": "ziti/install/overview.html",
    "title": "| NetFoundry Ziti",
    "keywords": "UNUSED this is the install/overview.md"
  },
  "ziti/manage/fabric-router.html": {
    "href": "ziti/manage/fabric-router.html",
    "title": "Edge Router | NetFoundry Ziti",
    "keywords": "Edge Router The Edge Router is responsible for the"
  },
  "glossary/glossary.html": {
    "href": "glossary/glossary.html",
    "title": "Glossary | NetFoundry Ziti",
    "keywords": "Glossary Here you will find a list of terms you may come across as you are using Ziti. Network Overlay, Overlay A Ziti network is implemented as an \"overlay\". A network overlay abstracts away the layers beneath it, providing a new set of abstractions for designing and implementing software and systems. Good programming abstractions allow developers to focus on the rules implemented by those abstractions without being concerned with the layers below the abstraction. Ziti's overlay allows developers to focus on connectivity between components without having to be concerned with low-level details of how that connectivity is managed. Service Definition A service definition is used to \"bind\" a service to a specific underlay network expression, through one or more nodes on a Ziti overlay network. A service definition usually includes a terminating router (or routers) and one or more SDK or underlay network endpoints where the service can be reached. Session A session is an \"instance\" of a service on behalf of an initiating endpoint, which is connected to a terminating endpoint. A session has strong identity and security between the initiating endpoint, terminating endpoint, and throughout the links between. A session selects a specific set of routers to traverse between the endpoints, and that path can change dynamically due to network performance. Initiating Router, Terminating Router An initiating router is the router which initiates a request for a session on behalf of a connected endpoint. A terminating router is the router which provides access to the service associated with the session request. Every session links an initiating endpoint (through an initiating router), with a terminating endpoint (through a terminating router). Initiating Endpoint, Terminating Endpoint See \"initiating router\" and \"terminating router\" above. The initiating endpoint is the endpoint responsible for requesting connectivity to a service. The terminating endpoint is the endpoint that provides the service. Path The path is the set of Ziti Routers traversed by a session from an initiating router to a terminating router. Ziti aggressively optimizes the path for throughput and reliability, and so it may change during the session. Underlay We refer to lower-level network concerns as \"underlay\". IP networking would be an example of an underlay concept. Xgress (Xctrl, Xmgmt), Ziti Fabric SDK Xgress is a set of extension components for the Ziti fabric, which enable overlay applications to participate in the overlay network. Xgress focuses on extending the data plane, providing interfaces for creating initiating and terminating endpoints. Xctrl and Xmgmt focus on extending the control and management planes of the fabric. Xgress is the core of the Ziti Fabric SDK. Ziti Controller, Controller A Ziti Controller is a process that is installed on a host, which allows it to coordinate a Ziti network. The Ziti Controller is designed to be extensible through Ziti fabric extension mechanisms (Xctrl, Xmgmt), which means that it is capable of hosting extensions to the fabric control and management planes. Ziti Edge, Edge The Ziti Edge implements the zero trust connectivity framework as an overlay application on top of the Ziti Fabric. The Ziti Edge provides connectivity implementations for a number of important endpoint types, including applications that embed Ziti connectivity through the Ziti Edge SDK. The Ziti Edge provides fallback connectivity solutions for non-Ziti applications using components like the Ziti tunnelers, and the Ziti proxy. Ziti Enabled Application A Ziti Enabled Application is an application that embeds the Ziti Endpoint SDK, such that it can participate on a Ziti network to either access or host services. Ziti Endpoint SDK, Endpoint SDK, SDK The Ziti Endpoint SDK provides software components that are designed to be embedded into customer applications so that they can participate natively in a Ziti network. The SDK targets golang, Swift, C, C#, and potentially other programming languages, allowing programs in those languages to work with idioms and concepts native to those environments. The SDK provides support for both accessing and hosting services that are available on a Ziti network. Ziti Fabric, Fabric The Ziti Fabric provides the core of the network overlay. The Ziti Fabric implements a routable mesh network, which can provide reliable connectivity between any two points on the network. The fabric provides software extension mechanisms that allow the overlay to be embedded into new overlay applications. The Ziti Edge is an example of an overlay application implemented on top of Ziti Fabric extension mechanisms (Xgress, Xctrl, Xmgmt). Ziti Network, Ziti Ziti is a modern, programmable network overlay with associated edge components, for application-embedded, zero trust network connectivity, written by developers for developers. Ziti is NetFoundry's next-generation programmable networking product. Ziti is used to create Ziti Networks. Ziti Router, Router A Ziti Router is a process that is installed on a host, which allows it to participate in a Ziti Fabric. The router is designed to be extensible through Ziti fabric extension mechanisms (Xgress), which means that it is capable of \"hosting\" overlay network applications like the Ziti Edge. Ziti Service, Service A Ziti network is primarily concerned with providing access to \"services\". A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. A Ziti Service is defined by a strong, extensible identity, rather than by an expression of an underlay concept. This means that services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti service would be defined by a name and/or a certificate, rather than by a DNS name or an IP address (underlay concepts). Ziti Service, Service - Hosted Similar to a Ziti Service however the destination is not described as an IP address and port but rather it is expressed as a Ziti Identity. When used with a Ziti SDK it is possible to create a truly zero-trust application. Ziti Tunneler, Tunneler A Ziti Tunneler provides connectivity for applications that are not Ziti enabled. Our tunneler implementations provide an underlay connectivity component (TUN, tproxy, etc.), and then use the Ziti Endpoint SDK such that they can bridge connectivity onto the Ziti network."
  },
  "ziti/downloads/enroller-lts.html": {
    "href": "ziti/downloads/enroller-lts.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Windows MacOS Linux"
  },
  "ziti/identities/creating.html": {
    "href": "ziti/identities/creating.html",
    "title": "Creating an Identity | NetFoundry Ziti",
    "keywords": "Creating an Identity The mechanism for creating identities is influenced by how your Ziti network is setup, specifically how the PKI is established. Identities are itegrally linked to the PKI configured in a given Ziti network and directly affects how identites are created. There are generally three groups of identities which can be created: One Time Token (ott) identites using the configured PKI One Time Token (ott) identites using a 3rd Party CA 3rd Party auto-enrolled identities Choosing an Identity Type Choosing which type of identity you are creating comes down to whether you are using a 3rd Party CA or not. If the network does not have a 3rd Party Certificate configured the only option is to use the One Time Token identity. If one or more 3rd Party CA is installed you will need to understand the intention of each 3rd Party certificate. Each of the types of identities are secure it just depends on your actual network setup as to which type to choose. If you don't know - just use the one time token identity. The identity can always be recreated at a later date and replaced if necessary. One Time Token (OTT) One time token identities are the type of identities available to all Ziti networks. A one time token identity will have a token generated at the time of the identity's creation. This token is then submitted at some point in the future as part of the enrollment process. Once an identity is successfully enrolled - the one time token is no longer valid and cannot be used to enroll the same identity again. One time tokens are delivered from the Ziti Controller as a jwt and the token expires 24 hours after the identity is created. The token is downloadable via the basic UI provided in the Ziti Edge - Developer Edition . After you create a user you can go to the Identities page and click the icon that looks like a certificate to download the .jwt file. You can also create a one time token identity using the ziti cli tool available on the path of the Ziti Edge - Developer Edition . This command will create a new identity and output the jwt to the selected path. You can then transfer the .jwt file to its intended destination. #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt 3rd Party CA - Overview The Ziti Controller is capable of using an existing PKI for authentication and authorization rather than to PKI configured in the Ziti Controller. Certificates that are not controlled by the Ziti Controller are referred to as \"3rd party\". If you have an existing PKI setup you wish to reuse or if you are just interested in learning how to use a 3rd Party CA this section is for you. Note Reusing a PKI is not a simple topic and managing and maintaining a PKI is out of the scope of this guide. A 3rd Party CA will need to be created and the public certificate uploaded into the Ziti Controller. After using an existing PKI to reuse/generate a certificate, the Ziti Controller will be to create identities which will be expected to present a certificate during the connection process that is valid per the provided certificate. Adding a 3rd Party CA to the Ziti Controller Adding a certifate to the Ziti Controller is easy using the Ziti Console provided in the Ziti Edge - Developer Edition . New CA via UI New CA via REST On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format body: { \"name\": \"${string}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${string}\" } 3rd Party CA - One Time Token 3rd Party CA OTT enrollment is closely related to OTT Enrollment . The main difference is the utilization of a 3rd party CA certificate rather than the configured Ziti Edge CA and PKI. In this method, the system does not have access to the 3rd party CA private key and thus cannot provide CSR fulfillment capabilities. Instead it is assumed that the enrolling device has a separate process to acquire signed certificates. Rather than submitting a CSR the client uses an already acquired signed certificate as its client certificate for the enrollment request. The client certificate is validated against the CA certificate tied to the one time token. Similar to the OTT Enrollment process, identities must be provisioned ahead of enrollment in order to generate one time token required and to creat the jwt that can be delivered to enrolling devices. This means that the provisioning of the Ziti Edge identities and the client certificates must be coordinated. Identities can be enrolled with a one time token flow similar to the one time token flow . 3rd Party CA - Auto Enrolled CA Auto Enrollment is useful in situations where devices are provisioned with certificates en-mass that need to be able to register as identities within Ziti Edge. This enrollment method allows for device provisioning processes to skip the manual configuration of Ziti Edge and instead allow clients to present a signed client certificate to generate an identity during the enrollment process. The identity will grant the client access to authenticate only - any authorization will need to be done after the device identities have been created. A certificate can only be used for one identity. The Ziti Edge system does not allow the same certificate to be used for multiple identities. An enrollment request is comprised of a special enrollment URL used to perform an HTTP POST request using the signed client certificate as the TLS client certificate and an optional JSON payload that allows the client to specify the devices display name and internal username. See enrollment for more details on enrolling. New Identity via UI New Identity via UI On the left side click \"Certificate Authorities\" In the top right corner of the screen click the \"plus\" image to add a new Certificate Authority Enter the name of the Certificate Authority you would like to create Choose if the CA should be used for Enrollment (yes) and Auth (yes) Click save #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt"
  },
  "ziti/identities/enrolling.html": {
    "href": "ziti/identities/enrolling.html",
    "title": "Enrolling an Identity | NetFoundry Ziti",
    "keywords": "Enrolling an Identity All connections made to the Ziti network leverage mutual TLS which means every client needs a valid X509 certificate which it will present to the Ziti network during the connection process. The process of obtaining a key/certificate pair and presenting it securely to the Ziti Controller is called \"Enrollment\". Overview All identities need to be enrolled with the Ziti Controller so the Ziti Controller can authenticate the incoming connection. This process is slightly different for each type of identity. NetFoundry has created a tool to aid the enrollment process named ziti-enroller . It is recommended that you use ziti-enroller to complete the enrollment as the process itself complex. Enrollers are available here: Windows MacOS Linux One Time Token Enrollment - Internal PKI Perhaps the easiest path to an enrolled identity is by using the one time token enrollment flow. This flow leverages the PKI configured in the Ziti Controller. Using the one time token flow - the ziti-enroller will generate a private key and a certificate signing request for the Ziti Controller to sign. Follow these steps to enroll a one time token identity: create the Identity download or copy the jwt - this file contains the single use token run the ziti-enroller for your given operating system: ziti-enroller --jwt ${jwt_file} Important The output from the ziti-enroller is a json file which must be kept secure. This file contains within it the private key used to generate a certificate request which was sent to the Ziti Controller and signed. This file should not be transferred or shared and should not be moved from the machine unless you are confident you understand the risks involved in doing so. 3rd Party CA - One Time Token This process is similar to the One Time Token flow from above. This flow expects that a private key and certificate have already been created on the machine that is about to enroll and that the certificate presented is valid to a CA already uploaded to the Ziti Controller. Follow these steps to enroll a 3rd Pary CA - one time token identity: create the Identity download or copy the jwt - this file contains the single use token run the ziti-enroller for your given operating system. Notice you can provide the name of the identity : ziti-enroller -v --jwt ${jwt_file} --cert ${identity_path_to_cert} --key ${identity_path_to_key} --idname ${identity_name} 3rd Party CA - Auto This enrollment process is almost entirely automated. With \"auto\" no identity needs to exist prior to enrollment. The act of enrolling the identity actually creates the identity. Like \"3rd Party CA - One Time Token\" - this flow expects that a private key and certificate have already been created on the machine that is about to enroll and that the certificate presented is valid to a CA already uploaded to the Ziti Controller. This flow also requires that a jwt specifically created for enrollment be downloaded from the CA and the CA uploaded needs to be valid for isAutoCaEnrollmentEnabled. You can get the .jwt by downloading the file from: ${controller_uri}/cas/${ca_id}/jwt"
  },
  "ziti/manage/manage.html": {
    "href": "ziti/manage/manage.html",
    "title": "Managing Ziti | NetFoundry Ziti",
    "keywords": "Managing Ziti Ziti management needs to be hands off. The only times one should be expected to be concerned with managing a Ziti instance is during the initial installation and when trying to expand the Ziti footprint. Installation Ziti Edge - Developer Edition An initial, simple installation of Ziti is already provided for you when using the Ziti Edge - Developer Edition . The installation will contain a Ziti Controller , a Ziti Edge Router and corresponding PKI . See the corresponding sections for additional details. Ziti Installation - the long way At its most simple, a basic Ziti Network is composed of only two (or three depending on whether you count the database) components. The Ziti Controller and a Ziti Edge Router . (Note: these executables are not currently available for separate download but will be coming in the months ahead.) Expanding Ziti At this time Ziti is only offered as the Ziti Edge - Developer Edition which is not expandable beyond a single node at this time. As you would exepct, allowing Ziti to be expanded past the developer experience is planned. Check back in the coming months for more information."
  },
  "ziti/manage/pki-troubleshooting.html": {
    "href": "ziti/manage/pki-troubleshooting.html",
    "title": "PKI Troubleshooting | NetFoundry Ziti",
    "keywords": "PKI Troubleshooting Configuring a Ziti Network's PKI can be confusing. Validating a single side of a mutual TLS connection is straightforward it becomes tedious to ensure all the certificates and cas in use are valid when you have a fully configured Ziti Network. It's the goal of this page to make diagnosing PKI issues eaiser. Prerequisites The following steps are bash-based functions and use the openssl , jq and ruby commands. If you don't have bash, openssl and ruby - this page is not for you! Do your best to follow along with the scripts and guidance herein or just install bash, openssl and ruby. All of which are widely available on linux/MacOS/Windows. The ruby and jq commands are not strictly required. They are used to make it easy for you to copy/paste these commands. The ruby command is used to translate yaml into json while the jq command is used to pull the specific values out of the given files. You can certainly do the same manually (withotu ruby and jq ) if you choose. Define the verifyCertAgainstPool Function In your bash prompt copy and paste these two functions: function yaml2json() { ruby -ryaml -rjson -e 'puts JSON.pretty_generate(YAML.load(ARGF))' $* } function verifyCertAgainstPool() { if [[ \"\" == \"$1\" ]] then printUsage \"verifyCertAgainstPool\" return 1 fi if [[ \"\" == \"$2\" ]] then printUsage \"verifyCertAgainstPool\" return 1 fi echo \" Verifying that this certificate:\" echo \" - $1\" echo \" is valid for this ca pool:\" echo \" - $2\" echo \"\" openssl verify -partial_chain -CAfile \"$2\" \"$1\" if [ $? -eq 0 ]; then echo \"\" echo \"============ SUCCESS! ============\" else echo \"\" echo \"============ FAILED TO VALIDATE ============\" fi } Validating the PKI Every connection in a Ziti Network is mutally authenticated via X509 certificates. It is easiest to first identify the two components trying to communicate to isolate and minimize the configuration and files that need to be inspected. Below you will find sections relevant to each of the pieces of Ziti which connect. Each section will refer to a bash variable that is expected to be established before running the command. This variable is intended to make it easier for you to simply copy/paste the command and determine if the configuration is valid or not. Using the provided bash function above - you will see one of two results: Success verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem /path/to/cert-to-test.cert: OK ============ SUCCESS! ============ Failure verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem C = US, ST = NC, L = Charlotte, O = NetFoundry, OU = Ziti, CN = 87f8cee9-b288-49f1-ab90-b664af29e17a error 20 at 0 depth lookup: unable to get local issuer certificate error /path/to/cert-to-test.cert: verification failed ============ FAILED TO VALIDATE ============ Ziti Edge Router to Controller Variables to Establish Manually These two variables represent the Ziti Edge Router configuration file and the Controller configuration file. edge_router_config_file=/path/to/edge-router.yaml controller_config_file=/path/to/controller.yaml Variables - Copy/Paste These commands extract the files specified in the configuration and store them into the assigned variables. edge_router_cert=$(yaml2json $edge_router_config_file | jq -rj .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -rj .edge.enrollment.signingCert.cert) Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool $edge_router_cert $signing_cert verifyCertAgainstPool $controller_cert $edge_router_ca Ziti Client to Controller - API Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/test_identity.json controller_config_file=/path/to/controller.yaml Variables - Copy/Paste These commands will extract the cert and ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.cert $identity_file | cut -d \":\" -f2 > /tmp/identity.cert jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca These commands extract the files specified in the configuration and store them into the assigned variables. controller_cert=$(yaml2json $controller_config_file | jq -rj .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -rj .edge.enrollment.signingCert.cert) controller_api_server_cert=$(yaml2json $controller_config_file | jq -rj .edge.api.identity.server_cert) if [[ \"null\" == \"$controller_api_server_cert\" ]]; then controller_api_server_cert=$(yaml2json $controller_config_file | jq -rj .identity.server_cert); fi Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool /tmp/identity.cert $signing_cert verifyCertAgainstPool $controller_api_server_cert /tmp/identity.ca Ziti Client to Ziti Edge Router - Data Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/test_identity.json edge_router_config_file=/path/to/edge_router.yaml Variables - Copy/Paste This command will extract the ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca This command extracts the file specified in the configuration and stores it into the assigned variable. edge_router_cert=$(yaml2json $edge_router_config_file | jq -rj .identity.cert) Commands to Verify PKI Configuration The following command should report SUCCESS. verifyCertAgainstPool $edge_router_cert /tmp/identity.ca"
  },
  "ziti/quickstarts/quickstart-overview.html": {
    "href": "ziti/quickstarts/quickstart-overview.html",
    "title": "Ziti Quickstarts | NetFoundry Ziti",
    "keywords": "Ziti Quickstarts Here you will find our quickstarts. These pages are designed to get you up and running and working with Ziti with minimal friction. Grab a quickstart and try it out. Once you have completed the quickstart you'll have a foundation for making changes and customizations."
  },
  "ziti/cli-snippets/login.html": {
    "href": "ziti/cli-snippets/login.html",
    "title": "| NetFoundry Ziti",
    "keywords": "#load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge controller login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert"
  },
  "api/clang.html": {
    "href": "api/clang.html",
    "title": "| NetFoundry Ziti",
    "keywords": "This is the c# sdk"
  },
  "ziti/clients/android.html": {
    "href": "ziti/clients/android.html",
    "title": "Android | NetFoundry Ziti",
    "keywords": "Android The Android tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "ziti/clients/ios.html": {
    "href": "ziti/clients/ios.html",
    "title": "iOS | NetFoundry Ziti",
    "keywords": "iOS The iOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "ziti/clients/macos.html": {
    "href": "ziti/clients/macos.html",
    "title": "MacOS | NetFoundry Ziti",
    "keywords": "MacOS The MacOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "ziti/clients/proxy-example.html": {
    "href": "ziti/clients/proxy-example.html",
    "title": "| NetFoundry Ziti",
    "keywords": "The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN"
  },
  "ziti/clients/sdks.html": {
    "href": "ziti/clients/sdks.html",
    "title": "Ziti SDKs | NetFoundry Ziti",
    "keywords": "Ziti SDKs If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/clients/tunneler-overview.html": {
    "href": "ziti/clients/tunneler-overview.html",
    "title": "| NetFoundry Ziti",
    "keywords": "A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. NetFoundry provides tunnelers for each major operating system. Windows MacOS Linux"
  },
  "ziti/manage/controller.html": {
    "href": "ziti/manage/controller.html",
    "title": "Ziti Controller | NetFoundry Ziti",
    "keywords": "Ziti Controller The Ziti Controller is the process that coordinates a Ziti network. It is responsible for authenticating incoming connections from identities and authorizing identities to services and provides a ReST-based API for other processes to interact with it. Prerequisite - Database There are a few prerequisites necessary before being able to deploy your first Ziti Controller. The first thing you will need is a database. At this time the Ziti Controller is using a Postgres instance. Setting up and managing a Postgres database is a complex task beyond the scope of this guide. This guide is intended to be illustrative of installing and managing the Ziti Controller and not maintaining a Postgres installation. Refer to the documentation from Postgres for asistance setting up a Postgres database. Prerequisite - PKI Public Key Infrastructure (PKI) is a complex topic. See the pki page for additional details about the sort of needs and considerations relevant to the Ziti Controller. Sizing Guidelines The Ziti Controller and Ziti Routers are still in the process of being stress tested. We recommend starting with a small scale deployment until key performance indicators start to hint that the server requires more resources. A Ziti network will have two important metrics: CPU and network capacity. Modest sized networks require minimal investments in infrastructure. Start with small machines and increase as needed. Configuration The Ziti Controller is configured using a yaml file. An example configuration file can be found here . Each section is annotated and should provide you enough information to modify a given setting. Most of the fields are straight-forward. The pki-related fields are the ones you will need to pay particular attention to. See the pki page for relevant information on pki settings. Logging The Ziti components log all output to standard output. Logging to standard out, instead of to configurable files, etc., is a \"lighter\" approach to logging that is more easily integrated into more different kinds of environments. Logging to files and implementing feautres like file rotation is a solved problem and not one that the Ziti components try to solve. Instead look to alternatives which are capable of watching standard out and aggregating the results for you. There are many solutions available to collect, aggregate and display logs. Search for and implement a solution that works for you and your needs. Log Format The output from Ziti components comes in three distinct styles. Choose the style of logging that is right for you. pfxlog - a human-readible format leveraging ascii escape codes to display colorized log level json - a machine-readible format targetting automated processes for log aggregation/searching text - a human-readible format using plain text (no ascii escape codes) Log Levels By default the Ziti components will log at the INFO level. This means that log messages INFO, WARNING, ERROR and FATAL will all be captured and output. Ziti components all support verbose logging by adding --verbose or -v to the command being executed. Verbose mode will add DEBUG log messages and as the name implies this log level is much more verbose. Often when debugging adding verbose mode will aid in identifying issues."
  },
  "ziti/manage/router-overview.html": {
    "href": "ziti/manage/router-overview.html",
    "title": "Ziti Router | NetFoundry Ziti",
    "keywords": "Ziti Router A Ziti Router is a process that is installed on a host which allows it to participate in a Ziti network. There are two types of routers: edge routers and fabric routers. At this time the edge router is available for use with a Ziti Edge - Developer Edition ( AWS / Azure ). Support for fabric routers is planned soon. Read more about edge routers here ."
  },
  "ziti/manage/tunneler.html": {
    "href": "ziti/manage/tunneler.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "ziti/quickstarts/networks-overview.html": {
    "href": "ziti/quickstarts/networks-overview.html",
    "title": "Ziti Networks | NetFoundry Ziti",
    "keywords": "Ziti Networks Provisioning a new network from the ground up for use in a developement enviroment is easy with the Ziti Edge - Developer editions NetFoundry has provided. Choose a provider and go from nothing to network quickly and easily! AWS Azure"
  },
  "ziti/quickstarts/network/aws-quickstart.html": {
    "href": "ziti/quickstarts/network/aws-quickstart.html",
    "title": "Ziti Quickstart AWS: Ziti Edge - Developer Edition | NetFoundry Ziti",
    "keywords": "Ziti Quickstart AWS: Ziti Edge - Developer Edition This guide will get you up and running with a demonstrable service in only a few minutes. If you are unfamiliar with the relevant Ziti concepts refer to the overview . From Nothing to Network To get started with Ziti here are the steps you will need to accomplish: Get Ziti Obtain, then change the default password Create an Identity Enroll the Identity Create a Service Create an AppWAN Test the Service Start Ziti Getting Started in AWS This guide will leverage an Amazon Machine Image (AMI) delivered via the AWS Marketplace . Using the image you will have an instance of Ziti to use as you please within minutes. If you are unfamiliar AWS you'll want to take some time to come up to speed. You will need an account, and you'll want to become familiar with the console. Start here and when you feel ready - come back to this guide. Important Note for Starting a Ziti Instance NetFoundry has provided the Ziti Edge - Developer Edition to make it easy for you to deploy a fully functional Ziti-based network. Follow the prompts and launch a new AMI. You will need to make a few key decisions that might affect your Ziti-based network. Important This is IMPORTANT. Make sure you consider and understand any security implications of the choices made when starting the AMI Virtual Private Cloud (VPC): for the instance to be put into. Choosing the VPC will determine what network resources are available to your Ziti network Subnet: The subnet you choose further defines what resources the instance will have access to. If you have a service that is not visible to the public internet and you want to use Ziti to secure that service make sure you put the Ziti instance on the proper subnet Security Group: You will want to put the Ziti instance into a security group that allows access from the public internet on ports: 22, 443, 1280, 3022. port 22 - the default port that ssh uses. This is how you will log into the bare AMI after it is launched. port 443 - a small UI is delivered via a web server that runs on port 443, using self-signed certificates port 1280 - the preselected port the Ziti controller will serve its API over port 3022 - the preselected port for data channels to the Ziti Edge Router Public IP/DNS: Make sure the EC2 instance is assigned a public IP and a public DNS entry Important Make sure you have the private key corresponding to the public key you choose. Without the private key - you will not be able to authenticate to the bare AMI. Obtain and Change the Default Password When first launched - the instace will deposit a file into the file system at ~/.config/ziti/ziti-controller/credentials.json. Note Since this is your first Ziti deployment this system is expected to be transient. If the IP address or DNS entry changes (such as a system reboot) the image needs to be reconfigured becuase the certificates will no longer be valid. This file is used to reconfigure the system in this event and it happens automatically on startup. Now, ssh to the newly created machine. Once there you can obtain the username and password for your Ziti Controller by issuing this command: jq -r .password ~/.config/ziti/ziti-controller/credentials.json You can choose to keep this password or change it to something easier to remember. If you change the password, please remember to use a strong password which is not easy to guess. Tip Once the password is changed - update the credentials.json file with the current password if you want the system to automatically update the certificates in the event of the image losing its IP address or DNS entry. Change via UI Change via CLI These AMIs will be provided with a self-signed certificate generated during securely during the bootup process. See changing pki for more information. Log into the UI using the password obtained in the prior step In the lower left corner, click the icon that looks like a person and choose \"Edit Profile\" Enter the current password along with a new/confirmed password and click \"Save\" To change the administrator password using the CLI simply issue these commands: Note You will need to login one time in order to use the ziti cli: #load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge controller login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert #update the admin user. This command will prompt you to enter the password ziti edge controller update authenticator updb -s Create an Identity All connections to Ziti are mutually authenticated TLS connections. Identites map a given certificate to an identity within the Ziti Controller. Read more about Identities here Creating an identity via the UI or CLI is easy: New Identity via UI New Identity via CLI On the left side click \"Edge Identities\" In the top right corner of the screen click the \"plus\" image to add a new identity Enter the name of the identity you would like to create Choose the type: Device, Service, User (choose User for now) Leave the enrollment type as \"One Time Token\" Click save To create a new identity using the CLI simply issue these commands: #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt Enroll the New Identity Identities are not truly enabled until they are enrolled. Enrollment is a complex process. NetFoundy has created a tool specifically for this task to ensure safe and secure enrollment of identities. Download the enroller for your operating system. Windows MacOS Linux Download the jwt from the UI by clicking the icon that looks like a certificate (save the file as NewUser.jwt) or if you used the CLI from the output location specified when creating the user. In a command line editor, change to the folder containing the jwt. Enroll the identity by running ziti-enroller --jwt NewUser.jwt The ziti-enroller will output a new json file named NewUser.json . This file is precious and must be protected as it contains the identity of the given user. Create a Service With an identity created it's now time to create a service. Read more about Services here . For this example we are going to choose a simple website that is available on the open internet . This site will return the IP address you are coming from. Click this link now and discover what the your external IP is. New Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Enter \"ethzero-ui\" Enter a host name for the service. Enter \"ethzero.ziti.ui\" Enter port 80 Choose Router \"ziti-gw01\" For Endpoint Service choose: protocol = tcp host = eth0.me port = 80 Select \"demo-c01\" for the cluster Leave Hosting Identities as is Click save To create a new service using the CLI simply issue these two commands: #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create service ethzero-cli \"ethzero.ziti.cli\" \"80\" \"$edgeRouter\" \"tcp:eth0.me:80\" -c \"$cluster\" Create an AppWAN AppWANs are used to to authorize identities to services and allow you to choose the terminating node for traffic destined to your service. Read more about AppWAN here New AppWAN via UI New AppWAN via CLI On the left side nav bar, click \"AppWANs\" In the top right corner of the screen click the \"plus\" image to add a new AppWAN Choose a name for the AppWAN. Enter \"my-first-appwan\" Choose the service(s) you want to add to the AppWAN. Make sure you pick ethzero-ui Choose the identity you created before (NewUser) Click save [To create an AppWAN using the CLI issue the following commands: #load the identity's id into an environment variable identity=$(ziti edge controller list identities | grep NewUser | cut -d \" \" -f2) #load the service id into an environment variable service=$(ziti edge controller list services | grep ethzero-cli | cut -d \" \" -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create app-wan my-first-cli-appwan -i $identity -s $service] Test It Ok, you're almost ready to test your Ziti setup! Now you need to acquire a pre-built client from NetFoundry. The simplest way to test your setup is to get the ziti-tunnel for your OS. Windows MacOS Linux The ziti-tunnel has a mode which acts as a proxy into the Ziti overlay network. You will need the enrolled identity json file created in the previous step and this will require running a command. Here are the steps to verify your Ziti network and configuration are all working properly: Open a command prompt ensure ziti-tunnel and NewUser.json are in the same directory and cd to this directory run the ziti-tunnel in proxy mode: ziti-tunnel proxy -i NewUser.json ethzero-ui:1111 ziti-tunnel proxy -i NewUser.json ethzero-cli:2222 navigate your web browser to (or use curl) to obtain your IP address by going to http://localhost:1111/ At this point you should see the external IP address of your instance. Delivered to your machine safely and securely over your Ziti network."
  },
  "ziti/quickstarts/network/azure-quickstart.html": {
    "href": "ziti/quickstarts/network/azure-quickstart.html",
    "title": "Ziti Quickstart Azure: Ziti Edge - Developer Edition | NetFoundry Ziti",
    "keywords": "Ziti Quickstart Azure: Ziti Edge - Developer Edition This guide will get you up and running with a demonstrable service in only a few minutes. If you are unfamiliar with the relevant Ziti concepts refer to the overview . From Nothing to Network To get started with Ziti here are the steps you will need to accomplish: Get Ziti Obtain, then change the default password Create an Identity Enroll the Identity Create a Service Create an AppWAN Test the Service Start Ziti Getting Started in Azure This guide will leverage an image delivered via the Azure Marketplace . Using the image you will have an instance of Ziti to use as you please within minutes. If you are unfamiliar Azure you'll want to take some time to come up to speed. You will need an account and you'll want to become familiar with the console. Start here and when you feel ready - come back to this guide. Important Note for Starting a Ziti Virtual Machine When starting your virtual machine instance of the Ziti Edge - Developer Edition via the Azure UI you will need to ensure the following: You have an Azure Resource Group and you are able to make the necessary changes From the Resource Group - click \"Add\" and find the Ziti Edge - Developer Edition Click \"Create\" to start the creation wizard On the \"Basics\" tab fill out the required options. Ensure you use the Username \"nfziti\" and uplaod a public key so you can SSH to the machine after its deployed Configure and choose options for \"Disks\" and \"Networking\" On the \"Management\" tab ensure the \"System assigned managed identity\" is set to \"On\" (the default is Off so you need to change this) Advance to and choose options for \"Advanced\" Advance to \"Tags\" - it's recommended you assingn a \"ZEDE\" (stands for Ziti Edge - Developer Edition) tag with a value that will be easy to find such as \"my-ziti\" or similar Create your virtual machine After the virtual machine is created and provisioned navigate back to the virtual machine. In the upper-right portion of the screen under \"DNS Name\" click configure to establish a DNS name. For simplicity choose a name that is guaranteed to be unique such as \"ziti-${ip.address}\". For example if the virtual machine is located in US Central and the IP address is 52.165.223.129 enter \"ziti-52-165-223-129.centralus.cloudapp.azure.com\" The final step is to add the network contributor role so that the machine can automatically discover network settings. This is used when the machine is rebooted. If the DNS address changes the Ziti Edge - Developer Edition will recreate certificates for the newly created DNS entry. From the Virtual Machine - click \"Access control (IAM)\" Click \"Add\" -> \"Add role assignment\" In the \"Add\" dialog choose: Role: Network Contributor Assign access to: Virtual Machine Subscription: (choose) Select: (choose your ZEDE virtual machine) Once the network contributor role is granted reboot the virtual machine. You are now able to access your \"Ziti Edge - Developer Edition\". Obtain and Change the Default Password When first launched - the instace will deposit a file into the file system at ~/.config/ziti/ziti-controller/credentials.json. Note Since this is your first Ziti deployment this system is expected to be transient. If the IP address or DNS entry changes (such as a system reboot) the image needs to be reconfigured becuase the certificates will no longer be valid. This file is used to reconfigure the system in this event and it happens automatically on startup. Now, ssh to the newly created machine. Once there you can obtain the username and password for your Ziti Controller by issuing this command: jq -r .password ~/.config/ziti/ziti-controller/credentials.json You can choose to keep this password or change it to something easier to remember. If you change the password, please remember to use a strong password which is not easy to guess. Tip Once the password is changed - update the credentials.json file with the current password if you want the system to automatically update the certificates in the event of the image losing its IP address or DNS entry. Change via UI Change via CLI These AMIs will be provided with a self-signed certificate generated during securely during the bootup process. See changing pki for more information. Log into the UI using the password obtained in the prior step In the lower left corner, click the icon that looks like a person and choose \"Edit Profile\" Enter the current password along with a new/confirmed password and click \"Save\" To change the administrator password using the CLI simply issue these commands: Note You will need to login one time in order to use the ziti cli: #load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge controller login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert #update the admin user. This command will prompt you to enter the password ziti edge controller update authenticator updb -s Create an Identity All connections to Ziti are mutually authenticated TLS connections. Identites map a given certificate to an identity within the Ziti Controller. Read more about Identities here Creating an identity via the UI or CLI is easy: New Identity via UI New Identity via CLI On the left side click \"Edge Identities\" In the top right corner of the screen click the \"plus\" image to add a new identity Enter the name of the identity you would like to create Choose the type: Device, Service, User (choose User for now) Leave the enrollment type as \"One Time Token\" Click save To create a new identity using the CLI simply issue these commands: #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt Enroll the New Identity Identities are not truly enabled until they are enrolled. Enrollment is a complex process. NetFoundy has created a tool specifically for this task to ensure safe and secure enrollment of identities. Download the enroller for your operating system. Windows MacOS Linux Download the jwt from the UI by clicking the icon that looks like a certificate (save the file as NewUser.jwt) or if you used the CLI from the output location specified when creating the user. In a command line editor, change to the folder containing the jwt. Enroll the identity by running ziti-enroller --jwt NewUser.jwt The ziti-enroller will output a new json file named NewUser.json . This file is precious and must be protected as it contains the identity of the given user. Create a Service With an identity created it's now time to create a service. Read more about Services here . For this example we are going to choose a simple website that is available on the open internet . This site will return the IP address you are coming from. Click this link now and discover what the your external IP is. New Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Enter \"ethzero-ui\" Enter a host name for the service. Enter \"ethzero.ziti.ui\" Enter port 80 Choose Router \"ziti-gw01\" For Endpoint Service choose: protocol = tcp host = eth0.me port = 80 Select \"demo-c01\" for the cluster Leave Hosting Identities as is Click save To create a new service using the CLI simply issue these two commands: #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create service ethzero-cli \"ethzero.ziti.cli\" \"80\" \"$edgeRouter\" \"tcp:eth0.me:80\" -c \"$cluster\" Create an AppWAN AppWANs are used to to authorize identities to services and allow you to choose the terminating node for traffic destined to your service. Read more about AppWAN here New AppWAN via UI New AppWAN via CLI On the left side nav bar, click \"AppWANs\" In the top right corner of the screen click the \"plus\" image to add a new AppWAN Choose a name for the AppWAN. Enter \"my-first-appwan\" Choose the service(s) you want to add to the AppWAN. Make sure you pick ethzero-ui Choose the identity you created before (NewUser) Click save [To create an AppWAN using the CLI issue the following commands: #load the identity's id into an environment variable identity=$(ziti edge controller list identities | grep NewUser | cut -d \" \" -f2) #load the service id into an environment variable service=$(ziti edge controller list services | grep ethzero-cli | cut -d \" \" -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create app-wan my-first-cli-appwan -i $identity -s $service] Test It Ok, you're almost ready to test your Ziti setup! Now you need to acquire a pre-built client from NetFoundry. The simplest way to test your setup is to get the ziti-tunnel for your OS. Windows MacOS Linux The ziti-tunnel has a mode which acts as a proxy into the Ziti overlay network. You will need the enrolled identity json file created in the previous step and this will require running a command. Here are the steps to verify your Ziti network and configuration are all working properly: Open a command prompt ensure ziti-tunnel and NewUser.json are in the same directory and cd to this directory run the ziti-tunnel in proxy mode: ziti-tunnel proxy -i NewUser.json ethzero-ui:1111 ziti-tunnel proxy -i NewUser.json ethzero-cli:2222 navigate your web browser to (or use curl) to obtain your IP address by going to http://localhost:1111/ At this point you should see the external IP address of your instance. Delivered to your machine safely and securely over your Ziti network."
  },
  "ziti/quickstarts/network/common-quickstart.html": {
    "href": "ziti/quickstarts/network/common-quickstart.html",
    "title": "Obtain and Change the Default Password | NetFoundry Ziti",
    "keywords": "Obtain and Change the Default Password When first launched - the instace will deposit a file into the file system at ~/.config/ziti/ziti-controller/credentials.json. Note Since this is your first Ziti deployment this system is expected to be transient. If the IP address or DNS entry changes (such as a system reboot) the image needs to be reconfigured becuase the certificates will no longer be valid. This file is used to reconfigure the system in this event and it happens automatically on startup. Now, ssh to the newly created machine. Once there you can obtain the username and password for your Ziti Controller by issuing this command: jq -r .password ~/.config/ziti/ziti-controller/credentials.json You can choose to keep this password or change it to something easier to remember. If you change the password, please remember to use a strong password which is not easy to guess. Tip Once the password is changed - update the credentials.json file with the current password if you want the system to automatically update the certificates in the event of the image losing its IP address or DNS entry. Change via UI Change via CLI These AMIs will be provided with a self-signed certificate generated during securely during the bootup process. See changing pki for more information. Log into the UI using the password obtained in the prior step In the lower left corner, click the icon that looks like a person and choose \"Edit Profile\" Enter the current password along with a new/confirmed password and click \"Save\" To change the administrator password using the CLI simply issue these commands: Note You will need to login one time in order to use the ziti cli: #load the current user/password into an environment variables ctrl_user=$(jq -r .username ~/.config/ziti/ziti-controller/credentials.json) ctrl_passwd=$(jq -r .password ~/.config/ziti/ziti-controller/credentials.json) ziticontroller=127.0.0.1 cert=~/.config/ziti/pki/intermediate/certs/intermediate.cert ziti edge controller login https://${ziticontroller}:1280 -u $ctrl_user -p $ctrl_passwd -c $cert #update the admin user. This command will prompt you to enter the password ziti edge controller update authenticator updb -s Create an Identity All connections to Ziti are mutually authenticated TLS connections. Identites map a given certificate to an identity within the Ziti Controller. Read more about Identities here Creating an identity via the UI or CLI is easy: New Identity via UI New Identity via CLI On the left side click \"Edge Identities\" In the top right corner of the screen click the \"plus\" image to add a new identity Enter the name of the identity you would like to create Choose the type: Device, Service, User (choose User for now) Leave the enrollment type as \"One Time Token\" Click save To create a new identity using the CLI simply issue these commands: #creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt Enroll the New Identity Identities are not truly enabled until they are enrolled. Enrollment is a complex process. NetFoundy has created a tool specifically for this task to ensure safe and secure enrollment of identities. Download the enroller for your operating system. Windows MacOS Linux Download the jwt from the UI by clicking the icon that looks like a certificate (save the file as NewUser.jwt) or if you used the CLI from the output location specified when creating the user. In a command line editor, change to the folder containing the jwt. Enroll the identity by running ziti-enroller --jwt NewUser.jwt The ziti-enroller will output a new json file named NewUser.json . This file is precious and must be protected as it contains the identity of the given user. Create a Service With an identity created it's now time to create a service. Read more about Services here . For this example we are going to choose a simple website that is available on the open internet . This site will return the IP address you are coming from. Click this link now and discover what the your external IP is. New Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Enter \"ethzero-ui\" Enter a host name for the service. Enter \"ethzero.ziti.ui\" Enter port 80 Choose Router \"ziti-gw01\" For Endpoint Service choose: protocol = tcp host = eth0.me port = 80 Select \"demo-c01\" for the cluster Leave Hosting Identities as is Click save To create a new service using the CLI simply issue these two commands: #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create service ethzero-cli \"ethzero.ziti.cli\" \"80\" \"$edgeRouter\" \"tcp:eth0.me:80\" -c \"$cluster\" Create an AppWAN AppWANs are used to to authorize identities to services and allow you to choose the terminating node for traffic destined to your service. Read more about AppWAN here New AppWAN via UI New AppWAN via CLI On the left side nav bar, click \"AppWANs\" In the top right corner of the screen click the \"plus\" image to add a new AppWAN Choose a name for the AppWAN. Enter \"my-first-appwan\" Choose the service(s) you want to add to the AppWAN. Make sure you pick ethzero-ui Choose the identity you created before (NewUser) Click save [To create an AppWAN using the CLI issue the following commands: #load the identity's id into an environment variable identity=$(ziti edge controller list identities | grep NewUser | cut -d \" \" -f2) #load the service id into an environment variable service=$(ziti edge controller list services | grep ethzero-cli | cut -d \" \" -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create app-wan my-first-cli-appwan -i $identity -s $service] Test It Ok, you're almost ready to test your Ziti setup! Now you need to acquire a pre-built client from NetFoundry. The simplest way to test your setup is to get the ziti-tunnel for your OS. Windows MacOS Linux The ziti-tunnel has a mode which acts as a proxy into the Ziti overlay network. You will need the enrolled identity json file created in the previous step and this will require running a command. Here are the steps to verify your Ziti network and configuration are all working properly: Open a command prompt ensure ziti-tunnel and NewUser.json are in the same directory and cd to this directory run the ziti-tunnel in proxy mode: ziti-tunnel proxy -i NewUser.json ethzero-ui:1111 ziti-tunnel proxy -i NewUser.json ethzero-cli:2222 navigate your web browser to (or use curl) to obtain your IP address by going to http://localhost:1111/ At this point you should see the external IP address of your instance. Delivered to your machine safely and securely over your Ziti network."
  },
  "ziti/downloads/enroller.html": {
    "href": "ziti/downloads/enroller.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Windows MacOS Linux"
  },
  "ziti/downloads/tunneler-lts.html": {
    "href": "ziti/downloads/tunneler-lts.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Windows MacOS Linux"
  },
  "ziti/install/pki.html": {
    "href": "ziti/install/pki.html",
    "title": "| NetFoundry Ziti",
    "keywords": "UNUSED this is install/pki - unreferenced"
  },
  "ziti/manage/edge-router.html": {
    "href": "ziti/manage/edge-router.html",
    "title": "Edge Router | NetFoundry Ziti",
    "keywords": "Edge Router The Edge Router is the entry point for Ziti-based clients. It is responsible for authenticating incoming connections by verifying the connecting client has a valid network session. It also routes traffic to whatever the destination is for the given service. In simple deployments - a single edge router might be deployed. This is the case with the Ziti Edge - Developer Edition . In the coming months it will be possible to produce complicated deployments having multiple Edge Routers deployed in a myriad of locations. Sizing Guidelines The Ziti Controller and Ziti Routers are still in the process of being stress tested. We recommend starting with a small scale deployment until key performance indicators start to hint that the server requires more resources. A Ziti network will have two important metrics: CPU and network capacity. Modest sized networks require minimal investments in infrastructure. Start with small machines and increase as needed. Configuration The Edge Router is configured using a yaml file. An example configuration file can be found here . Each section is annotated and should provide enough information to modify a given setting. Most of the fields are straight-forward. Edge Router Identity The pki-related fields in the identity section are important to understand and pay particular attention to. The files specified here are generated durring the process of enrolling the edge router. As is also stated in the configuration file these files do not need to exist before enrollment. These files will be written to during the enrollment process. This means the process running the enrollment will need the correct privledges grated to it in order to write - or overwrite those files. If the key specified in the identity section already exists - it will not be overwritten. Instead it will be used during the enrollment process. Logging The Ziti components log all output to standard output. Logging to standard out, instead of to configurable files, etc., is a \"lighter\" approach to logging that is more easily integrated into more different kinds of environments. Logging to files and implementing feautres like file rotation is a solved problem and not one that the Ziti components try to solve. Instead look to alternatives which are capable of watching standard out and aggregating the results for you. There are many solutions available to collect, aggregate and display logs. Search for and implement a solution that works for you and your needs. Log Format The output from Ziti components comes in three distinct styles. Choose the style of logging that is right for you. pfxlog - a human-readible format leveraging ascii escape codes to display colorized log level json - a machine-readible format targetting automated processes for log aggregation/searching text - a human-readible format using plain text (no ascii escape codes) Log Levels By default the Ziti components will log at the INFO level. This means that log messages INFO, WARNING, ERROR and FATAL will all be captured and output. Ziti components all support verbose logging by adding --verbose or -v to the command being executed. Verbose mode will add DEBUG log messages and as the name implies this log level is much more verbose. Often when debugging adding verbose mode will aid in identifying issues. Enrollment Enrollment is the process of securely generating information used to identify a given client. All endpoints need to be enrolled in one way or another. The Edge Router is a client of a Ziti Network and thus it too must be enrolled before it will be able to participate in a Ziti network. An Edge Router is enrolled using the ziti-router enroll command and sub-command. Running ziti-router enroll In order to enroll the Edge Router a valid configuration file is needed. After creating a valid configuration the jwt for the Edge Router also needs to be obtained from the Ziti Controller. The jwt can be retrieved from the Ziti Controller via the Ziti Controller's ReST API at https://${controller-name}:${controller-port}/edge-routers. With a valid configuration file and jwt the router can now be enrolled using: ziti-router enroller [path to configuration file] --jwt [path to jwt] ."
  },
  "ziti/manage/pki.html": {
    "href": "ziti/manage/pki.html",
    "title": "Public Key Infrastructure (PKI) | NetFoundry Ziti",
    "keywords": "Public Key Infrastructure (PKI) All Ziti Networks leverage Public Key Infrastructure (PKI) to provide secure network connections. This page is not intended to be a comprehensive guide. What it is, is a set of rules that must be followed to properly configure a Ziti Network. If there are issues when connecting any portion of a Ziti Network to another - this page should serve as a starting point of understanding. Note PKI is a complex topic and it is recommended to be familiar with what is a PKI as well as how to properly use and configure a one before making any decisions about the PKI the Ziti Network uses. The Ziti Network allows the operator to declare any trust anchors as valid. This means Ziti does not need to be configured with a full chain of certificates which link fully back to a root CA. A configuration using a full chain back to a root CA is of course supported but it is not explicitly required. This allows the operator to configure a Ziti Network using one or more chains of trust back to the provided trust anchors. The sections below will describe where these trust anchors can be configured. Ziti Network components are required to present a certificate to other Ziti Network components during the connection establishment. This certificate will need to be valid per the configured trust anchor store being connected to. Ziti Controller The Ziti Controller has three distinct sections related to PKI: identity , edge.api.identity , edge.enrollment.signingCert . The edge.api.identity configuration section is optional and is provided to allow the external ReST-based endpoint to present a certificate that is different than the one configured in the identity section. Connections to the Ziti Controller are considered valid if the certificate presented during connection is signed by a trust anchor declared within the identity.ca configuration or if the certificate presented is signed by the certificate specified in the edge.enrollment.signingCert . PKI Configuration The identity section of the Ziti Controller configuration is used by the Ziti Controller when connections are established to or from other components of a Ziti Network. There are four sections in the identity block: cert , server_cert , key , ca . ca : A file representing a group of certificates with one or more certificate chains terminating at a trust anchor. When a Ziti Network component connects to the Ziti Controller and offers a certificate for validation the incoming connection is checked to see if it signed by a trust anchor specified in this file. key : Also referred to as the private key . It is generated first and used to produce the certificates specified in the cert and server_cert fields of the Ziti Controller configuration file. cert : The certificate presented to other Ziti Network components during connection establishment. server_cert : The certificate returned by the Ziti Controller when other Ziti Network components attempt to communicate to the Ziti Controller over the IP and port specified in the ctrl.listener or mgmt.listener fields of the Ziti Controller configuration file. If an edge section is present in the configuration file and no edge.api.identity section exists this certificate is also returned to incoming connections to the edge.api.advertise endpoint. Edge Router An Edge Router has one section related to PKI: identity . It is important to note that an Edge Router will manage its own PKI. Allowing the Edge Router to manage its own PKI is almost certainly desired. The only setting that an operator may wish to provide is the key field of the identity. This field is treated differently than the other values specified. If the key specified does not exist a new key will be generated. If the key provided exists the Edge Router will use it and the other fields will be regenerated and overwritten as necessary. The certificate generated will be signed by the Ziti Controller using the certificate specified in edge.enrollment.signingCert . PKI Configuration The identity section of the Edge Router configuration is used by the Edge Router when connections are established to or from the other components of a Ziti Network. There are four sections in the identity block: cert , server_cert , key , ca . ca : A file representing a group of certificates with one or more certificate chains terminating at a trust anchor. When a Ziti Network component connects to the Edge Router and offers a certificate for validation the incoming connection is checked to see if it signed by a trust anchor specified in this file. key : Also referred to as the private key . It is generated first and used to produce the certificates specified in the cert and server_cert fields of the Edge Router configuration file. cert : The certificate presented to other Ziti Network components during connection establishment. server_cert : The certificate returned by the Edge Router when other Ziti Network components attempt to communicate to the Edge Router over the IP and port specified in the ctrl.listener or mgmt.listener fields of the Edge Router configuration file. Third Party CA (optional) A third party CA is one which is maintained and managed entirely outside of the Ziti Network. This is an important feature for organizations wishing to administer and maintain the certificates used by the different pieces of the Ziti Network. A Ziti Network is capable of using third party PKIs as the trust mechanism for enrollment and authentication of clients for a Ziti Network. With the PKI being managed externalliy a Ziti Network is never in posession of the private key. This means the Ziti Network cannot maintain nor distribute certificates necessary for creating secure connections. The Ziti Network is only capable of verifying if the certificate presented was signed by the externally managed PKI. Maintaining a PKI outside of the Ziti Network is a more complex configuration. If a PKI is already established and maintained externally setting up a Ziti Network with a third party CA may be desired. Registering the CA A Ziti Network will not trust any third party CA implicitly. Before a third party CA can be used for enrollment and authentication of clients in a Ziti Network it must be registered with the Ziti Controller to ensure certificates signed by the third party CA can be trusted. Registering a third party CA is done by using the ReST endpoint /cas from the Ziti Controller. To register a third party CA the following information is required to be posted to the endpoint: name : the desired name of the CA isEnrollmentEnabled : a boolean value indicating if the CA can be used for enrollment. Defaults to true. Set to false to prevent further enrollments using this CA isAuthEnabled : a boolean value indicating if the CA can be used for authentication. Defaults to true. Set to false to prevent all authentication from endpoints signed by this certificate Assuming the create request was well formed and successful, the response from this invocation will contain a field representing the id of the third party CA at data.id . The id of the third party CA will be needed when validating the third party CA. Validating the CA After being submitted to the Ziti Controller, the third party CA will have the isCsrValidated field set to false indicating it is not yet ready for use. A second step is needed to ensure the third party CA is setup properly as a CA. This step ensures the third party CA provided is capable of fullfilling CSR requests. Clients attempting to connect to a Ziti Network using the third party CA will be rejected. To validate the third party CA a CSR must be generated and fulfilled by the third party CA to generate a certificate with the common name (CN) field set to a value assigned by the Ziti Controller. The Ziti Controller /cas ReST endpoint can be interrogated to retrieve the details for a specific third party CA. The field necessary to validate the third party CA is data.verificationToken and is obtained at this endpoint. A certificate is then created and signed by the third party CA with the common name field set to the verificationToken. To finish verifying the third party CA, the certificate created with the verificationToken is posted back to the Ziti Controller at /cas/${id}/verify . The id is also obtained during the creation process. After posting the certificate with the verificationToken as the common name the third party CA will change from isVerified=false to isVerified=true . PKI Troubleshooting Configuring a Ziti Network's PKI can be confusing. Validating a single side of a mutual TLS connection is straightforward it becomes tedious to ensure all the certificates and cas in use are valid when you have a fully configured Ziti Network. It's the goal of this page to make diagnosing PKI issues eaiser. Prerequisites The following steps are bash-based functions and use the openssl , jq and ruby commands. If you don't have bash, openssl and ruby - this page is not for you! Do your best to follow along with the scripts and guidance herein or just install bash, openssl and ruby. All of which are widely available on linux/MacOS/Windows. The ruby and jq commands are not strictly required. They are used to make it easy for you to copy/paste these commands. The ruby command is used to translate yaml into json while the jq command is used to pull the specific values out of the given files. You can certainly do the same manually (withotu ruby and jq ) if you choose. Define the verifyCertAgainstPool Function In your bash prompt copy and paste these two functions: function yaml2json() { ruby -ryaml -rjson -e 'puts JSON.pretty_generate(YAML.load(ARGF))' $* } function verifyCertAgainstPool() { if [[ \"\" == \"$1\" ]] then printUsage \"verifyCertAgainstPool\" return 1 fi if [[ \"\" == \"$2\" ]] then printUsage \"verifyCertAgainstPool\" return 1 fi echo \" Verifying that this certificate:\" echo \" - $1\" echo \" is valid for this ca pool:\" echo \" - $2\" echo \"\" openssl verify -partial_chain -CAfile \"$2\" \"$1\" if [ $? -eq 0 ]; then echo \"\" echo \"============ SUCCESS! ============\" else echo \"\" echo \"============ FAILED TO VALIDATE ============\" fi } Validating the PKI Every connection in a Ziti Network is mutally authenticated via X509 certificates. It is easiest to first identify the two components trying to communicate to isolate and minimize the configuration and files that need to be inspected. Below you will find sections relevant to each of the pieces of Ziti which connect. Each section will refer to a bash variable that is expected to be established before running the command. This variable is intended to make it easier for you to simply copy/paste the command and determine if the configuration is valid or not. Using the provided bash function above - you will see one of two results: Success verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem /path/to/cert-to-test.cert: OK ============ SUCCESS! ============ Failure verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem C = US, ST = NC, L = Charlotte, O = NetFoundry, OU = Ziti, CN = 87f8cee9-b288-49f1-ab90-b664af29e17a error 20 at 0 depth lookup: unable to get local issuer certificate error /path/to/cert-to-test.cert: verification failed ============ FAILED TO VALIDATE ============ Ziti Edge Router to Controller Variables to Establish Manually These two variables represent the Ziti Edge Router configuration file and the Controller configuration file. edge_router_config_file=/path/to/edge-router.yaml controller_config_file=/path/to/controller.yaml Variables - Copy/Paste These commands extract the files specified in the configuration and store them into the assigned variables. edge_router_cert=$(yaml2json $edge_router_config_file | jq -rj .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -rj .edge.enrollment.signingCert.cert) Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool $edge_router_cert $signing_cert verifyCertAgainstPool $controller_cert $edge_router_ca Ziti Client to Controller - API Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/test_identity.json controller_config_file=/path/to/controller.yaml Variables - Copy/Paste These commands will extract the cert and ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.cert $identity_file | cut -d \":\" -f2 > /tmp/identity.cert jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca These commands extract the files specified in the configuration and store them into the assigned variables. controller_cert=$(yaml2json $controller_config_file | jq -rj .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -rj .edge.enrollment.signingCert.cert) controller_api_server_cert=$(yaml2json $controller_config_file | jq -rj .edge.api.identity.server_cert) if [[ \"null\" == \"$controller_api_server_cert\" ]]; then controller_api_server_cert=$(yaml2json $controller_config_file | jq -rj .identity.server_cert); fi Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool /tmp/identity.cert $signing_cert verifyCertAgainstPool $controller_api_server_cert /tmp/identity.ca Ziti Client to Ziti Edge Router - Data Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/test_identity.json edge_router_config_file=/path/to/edge_router.yaml Variables - Copy/Paste This command will extract the ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca This command extracts the file specified in the configuration and stores it into the assigned variable. edge_router_cert=$(yaml2json $edge_router_config_file | jq -rj .identity.cert) Commands to Verify PKI Configuration The following command should report SUCCESS. verifyCertAgainstPool $edge_router_cert /tmp/identity.ca"
  },
  "ziti/manage/troubleshooting.html": {
    "href": "ziti/manage/troubleshooting.html",
    "title": "Troubleshooting | NetFoundry Ziti",
    "keywords": "Troubleshooting This is where troubleshooting information will be added. Right now the biggest issue people have had is during initial setup of a Ziti Network and with PKI configuration. As additional troubleshooting needs become apparent this page will be updated. PKI Troubleshooting Configuring a Ziti Network's PKI can be confusing. Validating a single side of a mutual TLS connection is straightforward it becomes tedious to ensure all the certificates and cas in use are valid when you have a fully configured Ziti Network. It's the goal of this page to make diagnosing PKI issues eaiser. Prerequisites The following steps are bash-based functions and use the openssl , jq and ruby commands. If you don't have bash, openssl and ruby - this page is not for you! Do your best to follow along with the scripts and guidance herein or just install bash, openssl and ruby. All of which are widely available on linux/MacOS/Windows. The ruby and jq commands are not strictly required. They are used to make it easy for you to copy/paste these commands. The ruby command is used to translate yaml into json while the jq command is used to pull the specific values out of the given files. You can certainly do the same manually (withotu ruby and jq ) if you choose. Define the verifyCertAgainstPool Function In your bash prompt copy and paste these two functions: function yaml2json() { ruby -ryaml -rjson -e 'puts JSON.pretty_generate(YAML.load(ARGF))' $* } function verifyCertAgainstPool() { if [[ \"\" == \"$1\" ]] then printUsage \"verifyCertAgainstPool\" return 1 fi if [[ \"\" == \"$2\" ]] then printUsage \"verifyCertAgainstPool\" return 1 fi echo \" Verifying that this certificate:\" echo \" - $1\" echo \" is valid for this ca pool:\" echo \" - $2\" echo \"\" openssl verify -partial_chain -CAfile \"$2\" \"$1\" if [ $? -eq 0 ]; then echo \"\" echo \"============ SUCCESS! ============\" else echo \"\" echo \"============ FAILED TO VALIDATE ============\" fi } Validating the PKI Every connection in a Ziti Network is mutally authenticated via X509 certificates. It is easiest to first identify the two components trying to communicate to isolate and minimize the configuration and files that need to be inspected. Below you will find sections relevant to each of the pieces of Ziti which connect. Each section will refer to a bash variable that is expected to be established before running the command. This variable is intended to make it easier for you to simply copy/paste the command and determine if the configuration is valid or not. Using the provided bash function above - you will see one of two results: Success verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem /path/to/cert-to-test.cert: OK ============ SUCCESS! ============ Failure verifyCertAgainstPool /path/to/cert-to-test.cert /path/to/capool.pem Verifying that this certificate: - /path/to/cert-to-test.cert is valid for this ca pool: - /path/to/capool.pem C = US, ST = NC, L = Charlotte, O = NetFoundry, OU = Ziti, CN = 87f8cee9-b288-49f1-ab90-b664af29e17a error 20 at 0 depth lookup: unable to get local issuer certificate error /path/to/cert-to-test.cert: verification failed ============ FAILED TO VALIDATE ============ Ziti Edge Router to Controller Variables to Establish Manually These two variables represent the Ziti Edge Router configuration file and the Controller configuration file. edge_router_config_file=/path/to/edge-router.yaml controller_config_file=/path/to/controller.yaml Variables - Copy/Paste These commands extract the files specified in the configuration and store them into the assigned variables. edge_router_cert=$(yaml2json $edge_router_config_file | jq -rj .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -rj .edge.enrollment.signingCert.cert) Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool $edge_router_cert $signing_cert verifyCertAgainstPool $controller_cert $edge_router_ca Ziti Client to Controller - API Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/test_identity.json controller_config_file=/path/to/controller.yaml Variables - Copy/Paste These commands will extract the cert and ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.cert $identity_file | cut -d \":\" -f2 > /tmp/identity.cert jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca These commands extract the files specified in the configuration and store them into the assigned variables. controller_cert=$(yaml2json $controller_config_file | jq -rj .identity.cert) signing_cert=$(yaml2json $controller_config_file | jq -rj .edge.enrollment.signingCert.cert) controller_api_server_cert=$(yaml2json $controller_config_file | jq -rj .edge.api.identity.server_cert) if [[ \"null\" == \"$controller_api_server_cert\" ]]; then controller_api_server_cert=$(yaml2json $controller_config_file | jq -rj .identity.server_cert); fi Commands to Verify PKI Configuration Both of these commands should report SUCCESS. verifyCertAgainstPool /tmp/identity.cert $signing_cert verifyCertAgainstPool $controller_api_server_cert /tmp/identity.ca Ziti Client to Ziti Edge Router - Data Variables to Establish Manually These two variables represent the identity file in json for a Ziti client and the Controller configuration file. identity_file=/path/to/test_identity.json edge_router_config_file=/path/to/edge_router.yaml Variables - Copy/Paste This command will extract the ca from the enrolled identity file and put it into a file in the /tmp folder jq -j .id.ca $identity_file | cut -d \":\" -f2 > /tmp/identity.ca This command extracts the file specified in the configuration and stores it into the assigned variable. edge_router_cert=$(yaml2json $edge_router_config_file | jq -rj .identity.cert) Commands to Verify PKI Configuration The following command should report SUCCESS. verifyCertAgainstPool $edge_router_cert /tmp/identity.ca"
  },
  "test.html": {
    "href": "test.html",
    "title": "this is a markdown test | NetFoundry Ziti",
    "keywords": "this is a markdown test"
  },
  "samples/index.html": {
    "href": "samples/index.html",
    "title": "SDK Sample Usage | NetFoundry Ziti",
    "keywords": "SDK Sample Usage Here you'll find the samples we have produced to try to illustrate how to use the SDKs. Demo Weather C C# CLANG example is available here: https://github.com/nf-dev/ziti-sdk-c/tree/master/programs/sample_wttr/ /* Copyright 2019 Netfoundry, Inc. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at https://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ #include <nf/ziti.h> #include <string.h> #include <stdlib.h> #include <stdio.h> #include <uv.h> #define DIE(v) do { \\ int code = (v);\\ if (code != ZITI_OK) {\\ fprintf(stderr, \"ERROR: \" #v \" => %s\\n\", ziti_errorstr(code));\\ exit(code);\\ }} while(0) static size_t total; static nf_context nf; void on_data(nf_connection c, uint8_t *buf, int len) { if (len == ZITI_EOF) { printf(\"request completed: %s\\n\", ziti_errorstr(len)); NF_close(&c); NF_shutdown(nf); } else if (len < 0) { fprintf(stderr, \"unexpected error: %s\\n\", ziti_errorstr(len)); NF_close(&c); NF_shutdown(nf); } else { total += len; printf(\"%*.*s\", len, len, buf); } } static void on_write(nf_connection conn, ssize_t status, void *ctx) { if (status < 0) { fprintf(stderr, \"request failed to submit status[%zd]: %s\\n\", status, ziti_errorstr((int)status)); } else { printf(\"request success: %zd bytes sent\\n\", status); } } void on_connect(nf_connection conn, int status) { DIE(status); printf(\"sending HTTP request\\n\"); uint8_t *req = \"GET /Rochester HTTP/1.0\\r\\n\" \"Accept: */*\\r\\n\" \"Connection: close\\r\\n\" \"Host: wttr.in\\r\\n\" \"User-Agent: curl/7.59.0\\r\\n\" \"\\r\\n\"; DIE(NF_write(conn, req, strlen(req), on_write, NULL)); } void on_nf_init(nf_context _nf, int status, void* ctx) { DIE(status); nf = _nf; nf_connection conn; DIE(NF_conn_init(nf, &conn, NULL)); DIE(NF_dial(conn, \"demo-weather\", on_connect, on_data)); } int main(int argc, char** argv) { #if _WIN32 //changes the output to UTF-8 so that the windows output looks correct and not all jumbly SetConsoleOutputCP(65001); #endif uv_loop_t *loop = uv_default_loop(); DIE(NF_init(argv[1], loop, on_nf_init, NULL)); // loop will finish afger the request is complete and NF_shutdown is called uv_run(loop, UV_RUN_DEFAULT); printf(\"========================\\n\"); NF_free(&nf); } C# Example is available here: https://github.com/nf-dev/ziti-sdk-csharp/tree/initial_commit/Ziti.Core.Console using System; using System.IO; using System.Text; using System.Threading.Tasks; using NetFoundry; namespace Ziti.Core.Example { class Program { static async Task Main(string[] args) { byte[] wttrRequestAsBytes = Encoding.UTF8.GetBytes(\"GET / HTTP/1.0\\r\\n\" + \"Accept: *-/*\\r\\n\" + \"Connection: close\\r\\n\" + \"User-Agent: curl/7.59.0\\r\\n\" + \"Host: wttr.in\\r\\n\" + \"\\r\\n\"); string path = @\"c:/path/to/enrolled.id.json\"; //makes the output pretty - and not jumbly Console.OutputEncoding = Encoding.UTF8; /* Only needed when debugging Environment.SetEnvironmentVariable(\"ZITI_LOG\", \"6\"); NetFoundry.Ziti.OutputDebugInformation = true; */ ZitiIdentity id = new ZitiIdentity(path); id.InitializeAndRun(); //connect to the Ziti network //make a new stream using the identity ZitiStream zitiStream = new ZitiStream(id.NewConnection(\"demo-weather\")); //send the reqeust await zitiStream.WriteAsync(wttrRequestAsBytes, 0, wttrRequestAsBytes.Length); using (MemoryStream ms = new MemoryStream()) using (StreamReader sr = new StreamReader(ms)) { //display the bytes by reading from the stream and writing to the console await LocalPumpAsync(zitiStream, System.Console.OpenStandardOutput()); string output = sr.ReadToEnd(); System.Diagnostics.Debug.WriteLine(output); } } private const int DefaultStreamPumpBufferSize = 64 * 1024; public static async Task LocalPumpAsync(Stream input, Stream destination) { int count = DefaultStreamPumpBufferSize; byte[] buffer = new byte[count]; int numRead = await input.ReadAsync(buffer, 0, count).ConfigureAwait(false); while (numRead > 0) { destination.Write(buffer, 0, numRead); //writes are synchronous for now - without syncronous writes there's a lock that's //not freeing up //await destination.WriteAsync(buffer, 0, numRead).ConfigureAwait(false); numRead = await input.ReadAsync(buffer, 0, count).ConfigureAwait(false); } } } }"
  },
  "ziti/overview.html": {
    "href": "ziti/overview.html",
    "title": "Overview | NetFoundry Ziti",
    "keywords": "Overview Why Ziti? Ziti represents the next generation of secure networking for your applications and has arrived with the Ziti platform, created by NetFoundry, Inc ! The Ziti Controller and the Ziti Edge Router combine to form a secure, Zero Trust entry point into your network or as a secure zero-trust proxy to other hosted services. Getting started with Ziti If you are looking to jump right in feet first you can follow along with one of our up-and-running quickstart guides . The quickstart will leverage Amazon Web Services (AWS) and will have you launch an AMI which will get you up and running in no time. This environment is perfect for evaluators to get to know Ziti and the capabilities it offers. The environement was not designed for large scale deployment or for long-term usage. If you are looking for a managed service to help you run a truly global, scalable network browse over to our website at http://netfoundry.io to learn more. Overview of a Ziti Network The Ziti Network (Ziti) is composed of the following building blocks: Ziti Controller, Ziti Router, Ziti Edge Router, Ziti Edge Clients. These components are used in conjunction to provide secure connectivity between two points such as a client to a server. This type of network is considered an overlay network because it provides secure connectivity on top  or overlaying  existing networking infrastructure. Here's an overview of a network: ZITI CONTROLLER The NetFoundry Ziti Controller is the central function of the NetFoundry Ziti Network. The Ziti Controller provides the configuration plane. It is responsible for configuring Ziti services as well as being the central point for managing the identities used by users, devices and the nodes making up the Ziti Network. Lastly but critically, the Ziti Controller is responsible for authentication and authorization for every connection in the Ziti network. The Ziti Controller must be configured with public key infrastructure (pki). The configured pki is used to create secure, mutually authenticated TLS (mTLS) network connections between any two pieces of the Ziti Network. The Ziti Controller does not provide its own pki but for the Ziti Controller to sign certificate requests (CSR) the Ziti Controller will need to be configured with a key and certificate used for signing. (Optionally, the Ziti CLI can be used to generate a pki if needed) The Ziti Controller also supports using a third-party pki should the operator of the Ziti Network have an existing pki they wish to reuse. Utilizing a third-party CA pushes the burden of obtaining and distributing properly signed certificates to the operator of the Ziti network but for sophisticated customers this might make overall management of the network easier. The Ziti Controller uses an out of process database (Postgres) to store the information needed to manage the network. ZITI FABRIC ROUTER Ziti Fabric Routers are the fundamental building blocks of the Ziti Network. These routers are responsible for securely and reliably delivering traffic from one Ziti Network node to the traffics destination. Ziti Fabric Routers are linked together to form a mesh network. This mesh is constantly being monitored for latency and the fastest paths are used when routing traffic to the destination. The monitoring also allows for active failover to ensure a reliable network connection even in the case of a node failure. ZITI EDGE ROUTER Another fundamental building block of the Ziti Network is the Ziti Edge Router. The Ziti Edge Router is the entry point for Edge Clients connecting to the Ziti Network. The Ziti Edge Router is a specialized Ziti Router incorporating the functionality of a Ziti Router to enable it to route traffic over the Ziti network as a Ziti Router would to a given destination. The Ziti Edge Router in combination with the Ziti Controller is responsible for authenticating and authorizing Ziti Edge Clients. ZITI EDGE CLIENTS Connecting to the Ziti Network requires a Ziti Edge Client. Edge Clients are designed to work with both brownfield and greenfield applications. If the solution being developed includes developing new software NetFoundry offers SDKs targeting various languages and runtimes to provide fast, reliable and secure connectivity. These SDKs provide the capabilities needed to securely connect to the Ziti Network and are designed to be easily incorporated into the target application. When adding secure connectivity to an already existing solution NetFoundry offers specialized Edge Clients called tunnelers which provide seamless, secure connectivity and do not require changes to the target application. USING ZITI Once the Ziti Network is established and deployed the next step is to configure the software-powered network. The three main concepts necessary to configure a Ziti Network are: Identities, Services, and AppWANs. SERVICES A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. A Ziti Service is defined by a strong, extensible identity, rather than by an expression of an underlay concept. This means that services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti Service is defined by a name and/or a certificate, rather than by a DNS name or an IP address (underlay concepts). Services also declare a node where traffic that exits the Ziti Network needs to be sent do before exiting. Its possible for the node traffic enters to be the same it exits and its possible for traffic needing to traverse the Ziti Network Routers to reach the correct node. Simply specifying the node is all the end-user need do, the Ziti Network handles the rest. IDENTITIES Identities represent individual endpoints in the Ziti Network which can establish connectivity. All connections made within the Ziti Network are mutually authenticated using X509 Certificates. Every Identity is mapped to a given certificates signature. Ziti Edge Clients present this certificate when initiating connections to the Ziti Network. The presented certificate is used by the Ziti Network to authorize the client and enumerate the services the Identity is authorized to use. AppWAN The AppWAN is concept created to encapsulate the mapping between services and identities in a software-powered network. In the simplest terms, AppWANs are a group of services and a group of identities. The act of adding a service to an AppWAN will grant the identities in that AppWAN access to the given service. Similarly adding an identity to an AppWAN will grant that identity access to the services mapped in that AppWAN."
  },
  "ziti/appwans/create-appwan-cli.html": {
    "href": "ziti/appwans/create-appwan-cli.html",
    "title": "| NetFoundry Ziti",
    "keywords": "To create an AppWAN using the CLI issue the following commands. (ensure you are logged in ) #load the identity's id into an environment variable identity=$(ziti edge controller list identities | grep NewUser | cut -d \" \" -f2) #load the service id into an environment variable service=$(ziti edge controller list services | grep ethzero-cli | cut -d \" \" -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create app-wan my-first-cli-appwan -i $identity -s $service"
  },
  "ziti/appwans/create-appwan-ui.html": {
    "href": "ziti/appwans/create-appwan-ui.html",
    "title": "| NetFoundry Ziti",
    "keywords": "On the left side nav bar, click \"AppWANs\" In the top right corner of the screen click the \"plus\" image to add a new AppWAN Choose a name for the AppWAN. Enter then name for your AppWAN such as: \"my-first-appwan\" Choose the service(s) you want to add to the AppWAN. Choose the identity/identities you want to have access to the AppWAN Click save"
  },
  "ziti/appwans/creating.html": {
    "href": "ziti/appwans/creating.html",
    "title": "Creating an AppWAN | NetFoundry Ziti",
    "keywords": "Creating an AppWAN New AppWAN via UI New AppWAN via UI On the left side nav bar, click \"AppWANs\" In the top right corner of the screen click the \"plus\" image to add a new AppWAN Choose a name for the AppWAN. Enter then name for your AppWAN such as: \"my-first-appwan\" Choose the service(s) you want to add to the AppWAN. Choose the identity/identities you want to have access to the AppWAN Click save To create an AppWAN using the CLI issue the following commands. (ensure you are logged in ) #load the identity's id into an environment variable identity=$(ziti edge controller list identities | grep NewUser | cut -d \" \" -f2) #load the service id into an environment variable service=$(ziti edge controller list services | grep ethzero-cli | cut -d \" \" -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create app-wan my-first-cli-appwan -i $identity -s $service"
  },
  "ziti/appwans/overview.html": {
    "href": "ziti/appwans/overview.html",
    "title": "AppWANs | NetFoundry Ziti",
    "keywords": "AppWANs AppWANs are entities within the Ziti Controller which provide identities authorization to services. Having at least one AppWAN is vital because without at least one the Ziti network will have no identities authorized to send traffic over the Ziti network. Creating an AppWAN New AppWAN via UI New AppWAN via UI On the left side nav bar, click \"AppWANs\" In the top right corner of the screen click the \"plus\" image to add a new AppWAN Choose a name for the AppWAN. Enter then name for your AppWAN such as: \"my-first-appwan\" Choose the service(s) you want to add to the AppWAN. Choose the identity/identities you want to have access to the AppWAN Click save To create an AppWAN using the CLI issue the following commands. (ensure you are logged in ) #load the identity's id into an environment variable identity=$(ziti edge controller list identities | grep NewUser | cut -d \" \" -f2) #load the service id into an environment variable service=$(ziti edge controller list services | grep ethzero-cli | cut -d \" \" -f2) #update the admin user. This command will prompt you to enter the password ziti edge controller create app-wan my-first-cli-appwan -i $identity -s $service"
  },
  "api/csharp/NetFoundry.html": {
    "href": "api/csharp/NetFoundry.html",
    "title": "Namespace NetFoundry | NetFoundry Ziti",
    "keywords": "Namespace NetFoundry Classes Ziti A collection of static helper methods and properties for Ziti. ZitiConnection Represents a connection through the Ziti network. Supports both use-cases as well as callback-based. ZitiException Represents a Ziti-specific exception ZitiIdentity Represents an enrolled identity ZitiStream A representation of a standard which utilizes the NetFoundry network Enums ZitiStatus An enum representing the outcome of the given Ziti operation. Delegates ZitiConnection.OnConnected A delegate that represents the work to be done after a Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) operation. The result of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) may NOT be successful. It is important to verify the result by checking status ZitiConnection.OnDataReceived A delegate that represents the work to be done when data is recieved over the Ziti network. Only invoked after a successful Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) . Each time data is received it is important to verify the status is still OK ZitiConnection.OnDataWritten A delegate that is invoked after data has been put into the event loop. If there are any expensive resources held this is the callback to release those resources. Only needed when not using Ziti as a (callback based Ziti)"
  },
  "api/csharp/NetFoundry.ZitiConnection.OnDataWritten.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnDataWritten.html",
    "title": "Delegate ZitiConnection.OnDataWritten | NetFoundry Ziti",
    "keywords": "Delegate ZitiConnection.OnDataWritten A delegate that is invoked after data has been put into the event loop. If there are any expensive resources held this is the callback to release those resources. Only needed when not using Ziti as a (callback based Ziti) Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnDataWritten(ZitiStatus status, int bytesWritten, object context); Parameters Type Name Description ZitiStatus status A ZitiStatus that represents the state of the connection which initiated this callback. If NOT OK appropriate actions should be taken System.Int32 bytesWritten A count of how many bytes were able to be written. System.Object context The context that was supplied during the Write(Byte[], Int32, ZitiConnection.OnDataWritten, Object) invocation"
  },
  "api/csharp/NetFoundry.ZitiConnection.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.html",
    "title": "Class ZitiConnection | NetFoundry Ziti",
    "keywords": "Class ZitiConnection Represents a connection through the Ziti network. Supports both use-cases as well as callback-based. Inheritance System.Object ZitiConnection Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiConnection : IDisposable Methods | Improve this Doc Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) Establishes the necessary connecctivity and callbacks to send data through the NetFoundry network Declaration public void Dial(ZitiConnection.OnConnected onConnected, ZitiConnection.OnDataReceived onDataReceived) Parameters Type Name Description ZitiConnection.OnConnected onConnected Once the connection is established this callback is called ZitiConnection.OnDataReceived onDataReceived Called each time data is received over the NetFoundry network | Improve this Doc Dispose() Closes the ZitiConnection and cleans up as needed Declaration public void Dispose() | Improve this Doc Write(Byte[], Int32, ZitiConnection.OnDataWritten, Object) Writes the provided data over the NetFoundry network Declaration public void Write(byte[] data, int count, ZitiConnection.OnDataWritten onDataWritten, object context) Parameters Type Name Description System.Byte [] data A buffer holding the information to be sent over the NetFoundry network System.Int32 count How many bytes of the buffer (starting at position 0) to write ZitiConnection.OnDataWritten onDataWritten A callback to be invoked after the data is written to the NetFoundry network System.Object context Any object, provided back to the caller of this functionin the onDataWritten callback"
  },
  "api/csharp/NetFoundry.ZitiStream.html": {
    "href": "api/csharp/NetFoundry.ZitiStream.html",
    "title": "Class ZitiStream | NetFoundry Ziti",
    "keywords": "Class ZitiStream A representation of a standard which utilizes the NetFoundry network Inheritance System.Object ZitiStream Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiStream : Stream Constructors | Improve this Doc ZitiStream(ZitiConnection) Creates a ZitiStream from the provided ZitiConnection Declaration public ZitiStream(ZitiConnection conn) Parameters Type Name Description ZitiConnection conn The ZitiConnection to create a ZitiStream from Properties | Improve this Doc CanRead Indicates if the stream can be read from Declaration public override bool CanRead { get; } Property Value Type Description System.Boolean | Improve this Doc CanSeek Seeking is not supported Declaration public override bool CanSeek { get; } Property Value Type Description System.Boolean | Improve this Doc CanWrite indicates if the stream is ready for writing Declaration public override bool CanWrite { get; } Property Value Type Description System.Boolean | Improve this Doc Length unsupported - always returns 0 Declaration public override long Length { get; } Property Value Type Description System.Int64 | Improve this Doc Position unsupported - always returns 0 Declaration public override long Position { get; set; } Property Value Type Description System.Int64 Methods | Improve this Doc Dispose(Boolean) Disposes of the ZitiStream , cleaning up any retained resources Declaration protected override void Dispose(bool disposing) Parameters Type Name Description System.Boolean disposing | Improve this Doc Flush() Flushes bytes Declaration public override void Flush() | Improve this Doc PumpAsync(Stream) Asynchronously pumps this ZitiStream to/from the destination Declaration public Task PumpAsync(Stream destination) Parameters Type Name Description Stream destination Returns Type Description Task | Improve this Doc PumpAsync(Stream, Stream) Asynchronously pumps data between the input and destination Declaration public static Task PumpAsync(Stream input, Stream destination) Parameters Type Name Description Stream input The input stream Stream destination The destination stream Returns Type Description Task A which is awaitable | Improve this Doc Read(Byte[], Int32, Int32) Reads data into the provided buffer Declaration public override int Read(byte[] buffer, int offset, int count) Parameters Type Name Description System.Byte [] buffer The buffer to read data into System.Int32 offset The position in the bufer to begin appending data System.Int32 count The number of bytes to append Returns Type Description System.Int32 Returns the number of bytes read | Improve this Doc Seek(Int64, SeekOrigin) unsupported Declaration public override long Seek(long offset, SeekOrigin origin) Parameters Type Name Description System.Int64 offset SeekOrigin origin Returns Type Description System.Int64 | Improve this Doc SetLength(Int64) unsupported Declaration public override void SetLength(long value) Parameters Type Name Description System.Int64 value | Improve this Doc Write(Byte[], Int32, Int32) Writes the provided buffer over the ZitiNetwork Declaration public override void Write(byte[] buffer, int offset, int count) Parameters Type Name Description System.Byte [] buffer The buffer containing data to write System.Int32 offset The position in the buffer to read from System.Int32 count The number of bytes to write from the buffer"
  },
  "api/csharp/NetFoundry.Ziti.html": {
    "href": "api/csharp/NetFoundry.Ziti.html",
    "title": "Class Ziti | NetFoundry Ziti",
    "keywords": "Class Ziti A collection of static helper methods and properties for Ziti. Inheritance System.Object Ziti Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class Ziti : object Properties | Improve this Doc OutputDebugInformation A property which controls whether or not output is sent to the output stream. This is a global flag - when toggled all debug messages will show across any connection. Declaration public static bool OutputDebugInformation { get; set; } Property Value Type Description System.Boolean Methods | Improve this Doc Debug(String) A helper method to output messages helpful during debugging Ziti-related issues. Declaration public static void Debug(string msg) Parameters Type Name Description System.String msg"
  },
  "ziti/services/overview.html": {
    "href": "ziti/services/overview.html",
    "title": "Ziti Services | NetFoundry Ziti",
    "keywords": "Ziti Services A Ziti network is primarily concerned with providing access to \"services\". A service encapsulates the definition of any resource that could be accessed by a client on a traditional network. Services by themselves do not provide a complete mechanism for authorization. That is what an AppWAN is for. A service is defined by the following components: Name - the name of the service Ziti Router - the last Ziti Router traffic will be sent to Intercepting Host and Port - what DNS name or IP should be used when intecepting traffic Endpoint Service - (if not hosted - see below) the protocol, host, and port traffic sent to Hosting Identity - (is hosted - see below) the identity that will host the service Dark Services One of the benefits of using a Ziti service is that the actual service can be 'dark'. In fact this is the default for any service based entirely in Ziti. Place the service in a secure network with only Ziti in place and nobody in the world can access the service without a valid certificate/identity! Existing services can also be converted to dark via Ziti. Once Ziti is incorporated into an existing network and Ziti endpoints deployed the only access to these services can be through Ziti! Service Name Services defined on a Ziti Network have an almost limitless \"namespace\" available for identifying services. A Ziti service is be defined by a name and this name is registered with the Ziti Controller. Once declared, services can then be addressed directly by name from Ziti-aware clients. This means there are effecitvely a limitless number names available with no need for global DNS registration. The names assigned are unique to a Ziti Network and the application developer has total control over service names. Types of Services There are two basic types of serivces in a Ziti Network: hosted and non-hosted. Hosted Hosted services are the new edge. Ziti allows the developer to declare a service is \"hosted\". This means when a Ziti Client attempts to address the specified serivce the Ziti Network will route traffic to this endpoint automatically. Once the traffic is at the endpoint the traffic can be terminated inside the process space of a Ziti-powered application. When the traffic terminates inside a Ziti-powered application the application it never needs to leave the secure environment of the Ziti Network leading to turly zero-trust solutions! Non-Hosted Non-hosted services are services which are not terminated inside a Ziti-capable client. These services are somewhat similar conceptually to services behind a reverse proxy. In these services traffic is onboarded to the Ziti Network at an Ziti Edge Router and then exits the Ziti Network at the specified Ziti Edge Router. Ziti Router The Ziti Router portion of a service represents the final Ziti Router that traffic will be sent to. From this router the traffic will either be sent to a Ziti Endpoint or to a point outside the Ziti network over the underlay network. If the traffic is destined for a location that is not on the Ziti network overlay this is the router the Ziti network will end up sending the traffic from. If the router is sending traffic to another Ziti Endpoint then the service is said to be \"hosted\". Hosted services cannot specify a router - the Ziti network figures out the best path to the endpoint. Intercepting Host and Port Specified on the service when the traffic destination is outside of the Ziti network onto the underlay. If the Ziti client in use is capable of operating in a seamless/transparent mode then these values will specify the IPv4 address or DNS name to intercept. Any traffic sent to the specified address will be captured and if the destination port is the same as the specified intercepting port the traffic will be routed into the Ziti network. Endpoint Service Specified on the service when the traffic destination is outside of the Ziti network onto the underlay. These fields allow you to choose the protocol, host and port that the actual traffic will be sent to. Note that the host and port do not need to match those specified in the intercept host and port (for seamless/transparent ziti clients). Hosting Identity Specified on the service when the serivce is terminated at another Ziti Endpoint. This field is only valid when the router specified is set to \"hosted\". Creating a Service Here's how you can create a service. New non-hosted Service via UI New hosted Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose Router by name - for example \"ziti-gw01\" if you are using Ziti Edge - Developer Edition For Endpoint Service choose: protocol = tcp host = actual-hostname port = 2222 Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Leave Hosting Identities as is Click save On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-hosted-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose \"Hosted (No Router)\" for the Router Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Select one or more identities in \"Hosting Identities\" representing the identities which host the service Click save To change the administrator password using the CLI simply issue these two commands: # ------------------- helpful variables you may need ---------------------- #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the first edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) # ------------------- actual creation of the service ---------------------- #creates a new hosted service ziti edge controller create service ${svc_name} --hosted ${intercept_ip_dns} ${intercept_port} --host-ids ${comma separated identity list} #creates a non-hosted service ziti edge controller create service ${svc_name} \"${destinationHost}\" \"${destinationPort}\" \\ \"${edgeRouter}\" \"tcp:${interceptHost/ip}:${intercept port}\" -c \"${cluster}\""
  },
  "api/rest/create-ca-json.html": {
    "href": "api/rest/create-ca-json.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Verb: POST name: The name of the CA to create isAutoCaEnrollmentEnabled: controls if the CA can be used for automatic enrollment isOttCaEnrollmentEnabled: controls if the CA be used for one time token enrollment isAuthEnabled: controls if the CA is enabled for authentication. Devices can enroll but not connect if set to false certPem: the CA to upload in PEM format body: { \"name\": \"${string}\", \"isAutoCaEnrollmentEnabled\": ${true|false}, \"isOttCaEnrollmentEnabled\": ${true|false}, \"isAuthEnabled\": ${true|false}, \"certPem\": \"${string}\" }"
  },
  "samples/csharp.html": {
    "href": "samples/csharp.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "ziti/appwans.html": {
    "href": "ziti/appwans.html",
    "title": "| NetFoundry Ziti",
    "keywords": "delete"
  },
  "ziti/docker-quickstart.html": {
    "href": "ziti/docker-quickstart.html",
    "title": "Ziti Quickstart | NetFoundry Ziti",
    "keywords": "Ziti Quickstart This guide will get you up and running with a demonstrable service in only a few minutes. If you are unfamiliar with the relevant ziti concepts refer to the overview . This guide will utilize docker to stand up a full and complete network. If you are unfamiliar with docker take a moment and follow along with the steps for installing and running an application on your operating system. Once you feel comfortable, proceed to the steps below. From Nothing to Network Obtain the software necessary to run a Ziti network. You will need"
  },
  "ziti/quickstart.html": {
    "href": "ziti/quickstart.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "ziti/identities/create-identity-cli.html": {
    "href": "ziti/identities/create-identity-cli.html",
    "title": "| NetFoundry Ziti",
    "keywords": "#creates a new user named \"NewUser\" ziti edge controller create identity user \"NewUser\" -o NewUser.jwt"
  },
  "ziti/install/controller.html": {
    "href": "ziti/install/controller.html",
    "title": "| NetFoundry Ziti",
    "keywords": "UNUSED Hi from the controller file configuration: what does the version mean in config file configuration: why is there a 'db' in the config and why isn't it postgres configuration: logging explain - level/format control section:"
  },
  "ziti/services/create-service-cli.html": {
    "href": "ziti/services/create-service-cli.html",
    "title": "| NetFoundry Ziti",
    "keywords": "# ------------------- helpful variables you may need ---------------------- #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the first edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) # ------------------- actual creation of the service ---------------------- #creates a new hosted service ziti edge controller create service ${svc_name} --hosted ${intercept_ip_dns} ${intercept_port} --host-ids ${comma separated identity list} #creates a non-hosted service ziti edge controller create service ${svc_name} \"${destinationHost}\" \"${destinationPort}\" \\ \"${edgeRouter}\" \"tcp:${interceptHost/ip}:${intercept port}\" -c \"${cluster}\""
  },
  "ziti/clients/linux.html": {
    "href": "ziti/clients/linux.html",
    "title": "Linux | NetFoundry Ziti",
    "keywords": "Linux The linux tunneler is capable of operating in both transparent and proxy modes. In transparent mode the tunneler will interact with the operating system to establish intercept points. These intercept points correspond directly to the service definitions in place. ziti-tunnel supports several intercept modes, which are specified with a sub-command. Typically you will run ziti-tunnel with the run sub-command, which determines the preferred intercept mode based on the kernel drivers that are available on the host. $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33641 [ 0.006] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tproxy interceptor ... When started on a host that lacks iptables , the tproxy intercept mode initializer fails and ziti-tunnel attempts to use the tun intercept mode: $ sudo ziti-tunnel run ziti.json [ 0.001] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:37313 [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.009] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tun interceptor ziti-tunnel fails to start if no intercept modes can be successfully initialized: $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tun initialization failed: failed to open tun interface (name='', mtu=0): ioctl failed with 'invalid argument' [ 0.001] FATAL ziti/tunnel/cmd/ziti-tunnel/subcmd.run: failed to initialize an interceptor Intercept Modes tproxy tproxy is the preferred intercept mode when running on a Linux kernel that has the ip_tables kernel module installed. $ lsmod | grep ip_tables ip_tables 32768 5 iptable_filter,iptable_security,iptable_raw,iptable_nat,iptable_mangle ziti-tunnel manipulates routing tables and firewall rules when using the tproxy intercept mode. The NET_ADMIN Linux capability is required for these actions. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tproxy [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33355 [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.018] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.018] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.033] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.096] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.290] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.570] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding local.io = 169.254.1.1 to resolver The tproxy intercept mode creates a network listener that accepts connections at a randomly selected port on the loopback interface. Intercepted ziti service traffic directed to the listener by two mechanisms: Firewall Rules (iptables) The TPROXY iptables target is the primary intercept mechanism used by the tproxy intercept mode. The TPROXY target essentially sends packets to a local listener without actually modifying the packet's destination address fields. See https://www.kernel.org/doc/Documentation/networking/tproxy.txt and iptables-extensions(8) for more details on the TPROXY target. First, the tproxy interceptor links a new iptables chain to the PREROUTING chain: $ sudo iptables -nt mangle -L PREROUTING | grep NF-INTERCEPT NF-INTERCEPT all -- 0.0.0.0/0 0.0.0.0/0 Then it creates rules in the new chain for each intercepted service. You can view the tproxy rules in play: $ sudo iptables -nt mangle -L NF-INTERCEPT Chain NF-INTERCEPT (1 references) target prot opt source destination TPROXY tcp -- 0.0.0.0/0 5.9.243.187 /* wttr.in */ tcp dpt:443 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 169.254.1.1 /* ssh-local */ tcp dpt:22 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 1.2.3.4 /* netcat */ tcp dpt:22169 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 Packets with a destination address that matches the intercept address of a Ziti service are directed to ziti-tunnel's network listener (127.0.0.1:33355 in the examples above). This effectively enables ziti-tunnel to capture packets that are destined for any address using a single listener (and a single port). NOTE: netfilter rules were considered when implementing ziti-tunnel's tproxy intercept mode. netfilter is a slightly more modern than iptables and has a supported netlink API for manipulating rules without \"shelling out\" to the iptables command line utility. netfilter was ultimately abandoned because netfilter tproxy support requires kernel configuration options ( CONFIG_NFT_TPROXY , CONFIG_NFT_SOCKET ) that are not enabled in the default kernels of many common Linux distributions. Local Routes The TPROXY target is only valid in the PREROUTING iptables chain, which is traversed by incoming packets that were routed to the host over the network. A local route is necessary in order to get locally generated packets to traverse the PREROUTING chain: $ ip route show table local local 1.2.3.4 dev lo proto kernel scope host src 1.2.3.4 local 5.9.243.187 dev lo proto kernel scope host src 5.9.243.187 local 169.254.1.1 dev lo proto kernel scope host src 169.254.1.1 tun The tun intercept mode creates an ephemeral tun interface and configures it with the IP addresses of the services that are being proxied. ziti-tunnel manipulates network interfaces when using the tun intercept mode, which requires the NET_ADMIN Linux capability. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tun [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.012] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.012] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.031] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.089] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.280] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.502] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding myhost.io = 169.254.1.2 to resolver [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service ssh-local not hostable [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service netcat [ 2.506] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service netcat not hostable ... The addresses that ziti-tunnel adds to the tun interface are point-to-point addresses: $ ip addr show dev tun0 10: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 65535 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 169.254.1.1/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 5.9.243.187/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 169.254.1.2/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 1.2.3.4/32 scope host tun0 valid_lft forever preferred_lft forever The tun interface itself is assigned a link-local address, 169.254.1.1 in this case, and each intercepted service is represented by a point-to-point address with the remote address matching the intercept IP of the Ziti service. The tun intercept mode uses point-to-point addresses instead of local routes because local routes would result in the Linux networking stack receiving the packets that are routed to the tun interface. The point-to-point addresses ensure that the packets are delivered \"to the wire\", which mean that, for a tun interface, the packets will be picked up by ziti-tunnel when it reads data from the tun interface. proxy The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN DNS Server ziti-tunnel runs an internal DNS server by default. The DNS server must be first in the host's resolver configuration (e.g. resolve.conf). A self-test is performed when ziti-tunnel starts to ensure that its internal DNS server is configured in the system resolver: INFO[0002] dns server started on 127.0.0.1:53 INFO[0002] adding ziti-tunnel.resolver.test -> 19.65.28.94 to resolver INFO[0002] removing ziti-tunnel.resolver.test from resolver The test involves inserting a known hostname/IP address into the internal DNS server, and using the system resolver to retrieve the address of the hostname. ziti-tunnel will exit if the DNS self-test fails. Linux distributions typically manage the contents of /etc/resolv.conf, so simply editing the file will only work for a short time until /etc/resolv.conf is overwritten by the managing process. Resolver configuration changes must survive restarts of the Linux name resolution manager. Linux distrubutions use one of several name resolution managers. The simplest way to determine which name resolution manager is being used by your Linux distrubtion is to look at /etc/resolv.conf: $ ls -l /etc/resolv.conf If /etc/resolv.conf is a regular file, then it is most likely being managed by dhclient . If /etc/resolv.conf is a symlink to a file in /run/systemd/resolve, then it is being managed by systemd-resolved dhclient If your Linux distribution uses dhclient, you can configure the system resolver to use ziti-tunnel's internal DNS server first by adding the following to /etc/dhcp/dhclient.conf: prepend domain-name-servers 127.0.0.1; Then restart network manager. Unless you know the name of the NetworkManager systemd service on your Linux distrubtion, it's probably easiest to reboot the host. systemd-resolved $ sudo ln -sf /run/systemd/resolve/resolv.conf /etc $ echo -e \"[Resolve]\\nDNS=127.0.0.1\" | sudo tee /etc/systemd/resolved.conf.d/ziti-tunnel.conf $ sudo systemctl restart systemd-resolved If you are unable to control the resolver on your operating system, ziti-tunnel can use/update a hosts file for any hostnames that it tunnels: ziti-tunnel run --resolver file:///etc/hosts \"${HOME}/ziti.json\" IP Address Assignment If the service specifies a hostname for its address, ziti-tunnel resolves the hostname and adds the result to its internal DNS server: [0127] INFO adding myservice.mydomain.com -> 45.60.32.165 to resolver If the service hostname does not resolve, ziti-tunnel will find an unused link-local address and assign it to the route for the service: [0012] INFO adding bogushost.net -> 169.254.1.4 to resolver [0012] INFO ziti/tunnel/protocols/tcp.Listen: Accepting on 169.254.1.4:25 service=telnet"
  },
  "ziti/clients/overview.html": {
    "href": "ziti/clients/overview.html",
    "title": "Clients overview | NetFoundry Ziti",
    "keywords": "Clients overview"
  },
  "ziti/services/creating.html": {
    "href": "ziti/services/creating.html",
    "title": "Creating a Service | NetFoundry Ziti",
    "keywords": "Creating a Service Here's how you can create a service. New non-hosted Service via UI New hosted Service via UI New Service via CLI On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose Router by name - for example \"ziti-gw01\" if you are using Ziti Edge - Developer Edition For Endpoint Service choose: protocol = tcp host = actual-hostname port = 2222 Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Leave Hosting Identities as is Click save On the left side nav bar, click \"Edge Services\" In the top right corner of the screen click the \"plus\" image to add a new service Choose a name for the serivce. Example \"my-first-hosted-service\" Enter a host name for the service. Enter \"intercepted-hostname\" Enter the port you want intercepted: 1111 Choose \"Hosted (No Router)\" for the Router Select a cluster. If using Ziti Edge - Developer Edition choose \"demo-c01\" Select one or more identities in \"Hosting Identities\" representing the identities which host the service Click save To change the administrator password using the CLI simply issue these two commands: # ------------------- helpful variables you may need ---------------------- #load the default cluster id into an environment variable cluster=$(ziti edge controller list clusters | tr -s ' ' | cut -d ' ' -f4) #load the first edge router id into an environment variable edgeRouter=$(ziti edge controller list gateways | cut -d ' ' -f2) # ------------------- actual creation of the service ---------------------- #creates a new hosted service ziti edge controller create service ${svc_name} --hosted ${intercept_ip_dns} ${intercept_port} --host-ids ${comma separated identity list} #creates a non-hosted service ziti edge controller create service ${svc_name} \"${destinationHost}\" \"${destinationPort}\" \\ \"${edgeRouter}\" \"tcp:${interceptHost/ip}:${intercept port}\" -c \"${cluster}\""
  },
  "api/csharp.html": {
    "href": "api/csharp.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "ziti/clients/sdk-quickinfo.html": {
    "href": "ziti/clients/sdk-quickinfo.html",
    "title": "| NetFoundry Ziti",
    "keywords": "If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/clients/which-client.html": {
    "href": "ziti/clients/which-client.html",
    "title": "Choosing a client | NetFoundry Ziti",
    "keywords": "Choosing a client Once you have a Ziti Network - you are going to require a Ziti-aware client in order to access the network. There are two types of clients and depending on your needs you'll choose to either use a tunneler or you will use an SDK to securely access the Ziti Network. Choosing which type of client you will use to connect to a Ziti Network is a straightfoward process and comes down to a single question. If you are you installing Ziti in front of an existing application which has already been developed and deployed you need to use a tunneler . If you are developing a new product, starting from scratch and you want to take advantage of a fully zero-trust solution you will probably want to use an SDK. Tunnelers A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. NetFoundry provides tunnelers for each major operating system. Windows MacOS Linux Read more on using tunnelers here SDK If you are building a new application you have a unique opportunity to choose to use one of the Ziti SDKs and to create a truly zero-trust application from the start! Navigate over to the api page to learn more about which SDKs are avialable and for documentation focused on using these sdks."
  },
  "ziti/downloads/overview.html": {
    "href": "ziti/downloads/overview.html",
    "title": "Ziti Related Downloads | NetFoundry Ziti",
    "keywords": "Ziti Related Downloads Here you'll find links to the various binaries needed to make a Ziti network or client work. 0.5 Enroller Windows MacOS Linux Tunneler Windows MacOS Linux 0.4 Enroller Windows MacOS Linux Tunneler Windows MacOS Linux"
  },
  "ziti/downloads/tunneler.html": {
    "href": "ziti/downloads/tunneler.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Windows MacOS Linux"
  },
  "ziti/manage/logging-snippet.html": {
    "href": "ziti/manage/logging-snippet.html",
    "title": "Logging | NetFoundry Ziti",
    "keywords": "Logging The Ziti components log all output to standard output. Logging to standard out, instead of to configurable files, etc., is a \"lighter\" approach to logging that is more easily integrated into more different kinds of environments. Logging to files and implementing feautres like file rotation is a solved problem and not one that the Ziti components try to solve. Instead look to alternatives which are capable of watching standard out and aggregating the results for you. There are many solutions available to collect, aggregate and display logs. Search for and implement a solution that works for you and your needs. Log Format The output from Ziti components comes in three distinct styles. Choose the style of logging that is right for you. pfxlog - a human-readible format leveraging ascii escape codes to display colorized log level json - a machine-readible format targetting automated processes for log aggregation/searching text - a human-readible format using plain text (no ascii escape codes) Log Levels By default the Ziti components will log at the INFO level. This means that log messages INFO, WARNING, ERROR and FATAL will all be captured and output. Ziti components all support verbose logging by adding --verbose or -v to the command being executed. Verbose mode will add DEBUG log messages and as the name implies this log level is much more verbose. Often when debugging adding verbose mode will aid in identifying issues."
  },
  "ziti/quickstarts/kubernetes/README.html": {
    "href": "ziti/quickstarts/kubernetes/README.html",
    "title": "| NetFoundry Ziti",
    "keywords": "make a link to the ziti quickstart here mklink /j sidecar-tunnel c:\\git\\ziti\\quickstart\\kubernetes-sidecar-tunnel"
  },
  "ziti/quickstarts/kubernetes/sidecar-tunnel/kubernetes-sidecar-tunnel-quickstart.html": {
    "href": "ziti/quickstarts/kubernetes/sidecar-tunnel/kubernetes-sidecar-tunnel-quickstart.html",
    "title": "Kubernetes Sidecar Client | NetFoundry Ziti",
    "keywords": "Kubernetes Sidecar Client This guide shows you how to access a NetFoundry service from a pre-existing (or third party) application that's running in a Kubernetes Pod. To provide access to the service, we will deploy the ziti-tunnel NetFoundry client in a sidecar container. Overview The Ziti Network Quickstart walked you through standing up a Ziti instance and accessing a Ziti service from your workstation with ziti-tunnel . In this guide we'll deploy the same ziti-tunnel client, but instead of running it from the command line we will deploy it in a sidecar container in a Kubernetes Pod. This guide also demonstrates ziti-tunnel 's internal DNS server, which allows us to access NetFoundry services by hostname instead of IP address. Here's some detail on how the various intercept modes work on Linux Solution Overview Prerequisites Complete the Ziti Network Quickstart . This guide uses the Ziti Controller and Ziti Edge Router that are created in the Ziti Quickstart. Admin-level access to a Kubernetes cluster via kubectl . Create an Identity and AppWAN This guide will re-use the \"eth0.ziti.cli\" service that was created in the Ziti Network Quickstart. We will create a new identity for our client, with a new AppWAN that uses the eth0.ziti.cli service. Create the Identity: $ ziti edge controller create identity device tunnel-sidecar -o tunnel-sidecar.jwt Create the AppWAN: $ ziti edge controller create app-wan ziti-tunnel-appwan -i tunnel-sidecar -s eth0.ziti.cli Create a Kubernetes Secret The ziti-tunnel sidecar will access its identity by mounting a Kubernetes secret in the container. We can mount the JWT as a secret like this: $ kubectl create secret generic tunnel-sidecar.jwt --from-file=tunnel-sidecar.jwt Deploy the Pod Deploy a Pod that runs a client application and ziti-tunnel as a sidecar container. For this demonstration, the client application is wget . Our Pod runs wget in a loop so we can see content from our NetFoundry service in the Pod's logs. Save the following yaml to a file named tunnel-sidecar-demo.yaml apiVersion: v1 kind: PersistentVolumeClaim metadata: name: tunnel-sidecar-pv-claim spec: accessModes: - ReadWriteOnce resources: requests: storage: 1Gi --- apiVersion: apps/v1 kind: Deployment metadata: name: ziti-tunnel-sidecar-demo spec: replicas: 1 strategy: type: Recreate template: spec: containers: - image: busybox name: testclient command: [\"sh\",\"-c\",\"while true; do echo wget -qO - eth0.ziti.cli:80; sleep 5; done\"] - image: netfoundry/ziti-tunnel:0.5.7-2546 env: - name: NF_REG_NAME value: tunnel-sidecar volumeMounts: - name: tunnel-sidecar-jwt mountPath: \"/var/run/secrets/netfoundry.io/enrollment-token\" readOnly: true - name: ziti-tunnel-persistent-storage mountPath: /netfoundry restartPolicy: Always volumes: - name: ziti-tunnel-persistent-storage persistentVolumeClaim: claimName: ziti-tunnel-host-pv-claim - name: tunnel-sidecar-jwt secret: secretName: tunnel-sidecar.jwt You'll notice that the ziti-tunnel sidecar container has a few requirements: The name of the identity that is assumed by ziti-tunnel must be passed into the container with the NF_REG_NAME environment variable. The secret that we created above for the enrollment token must be mounted into the container at \"/var/run/secrets/netfoundry.io/enrollment-token\". A persistent volume must be mounted at \"/netfoundry\". This volume is used to save the json file that is created when the one-time enrollment token is used. If this volume is not persistent, you will need to provide a new enrollment token each time the Pod is restarted! Once the yaml is saved, we can deploy the Pod with kubectl $ kubectl apply -f ./tunnel-sidecar-demo.yaml Test the Service First we need to get the name of the Pod that Kubernetes deployed for us: $ kubectl get pods ziti-tunnel-sidecar-demo-749c476989-6wpfn 1/1 Running 0 42s Then we can tail the logs for the \"testclient\" container: $ kubectl logs -f ziti-tunnel-sidecar-demo-749c476989-6wpfn --container testclient 54.67.121.213 54.67.121.213 54.67.121.213 Notice that the wget client is using the DNS name that we provided in the Ziti service definition to make the request."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "| NetFoundry Ziti",
    "keywords": "Here you will find the information necessary to successfully use a Ziti SDK to create an application. If there is a term which is not familiar please refer to the glossary . Each SDK has certain syntax unique to the particular language the SDK is targetting. Each SDK presents an api which is as idomatic as possible to present a consistent look and feel for the language or runtime being used."
  },
  "ziti/clients/tunneler.html": {
    "href": "ziti/clients/tunneler.html",
    "title": "Tunnelers | NetFoundry Ziti",
    "keywords": "Tunnelers A tunneler is purpose-built software designed to connect applications which are not Ziti-aware to the Ziti Network. NetFoundry provides tunnelers for each major operating system. Windows MacOS Linux Each tunneller operates similarly. The goal is to have the tunneler intercecpt traffic destined for Ziti services and forward that traffic over the Ziti overlay instead of the underlay network. There are two basic modes a tunneler operate in: seamless and proxy. A seamless tunneler will transparently intercept traffic via IPv4 address or DNS whereas a tunneler in proxy mode works as a proxy. Seamless mode is transparent to existing services and applications. Proxy mode is not as transparent at all. It requires applications to send traffic to the localhost proxy specifically. This means when running in proxy mode - it does not do any intercepting at all. Here you can learn about the ways each tunneler operates and see the similarities as well as any differences. Linux The linux tunneler is capable of operating in both transparent and proxy modes. In transparent mode the tunneler will interact with the operating system to establish intercept points. These intercept points correspond directly to the service definitions in place. ziti-tunnel supports several intercept modes, which are specified with a sub-command. Typically you will run ziti-tunnel with the run sub-command, which determines the preferred intercept mode based on the kernel drivers that are available on the host. $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33641 [ 0.006] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tproxy interceptor ... When started on a host that lacks iptables , the tproxy intercept mode initializer fails and ziti-tunnel attempts to use the tun intercept mode: $ sudo ziti-tunnel run ziti.json [ 0.001] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:37313 [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.009] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: using tun interceptor ziti-tunnel fails to start if no intercept modes can be successfully initialized: $ sudo ziti-tunnel run ziti.json [ 0.000] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tproxy initialization failed: failed to initialize iptables handle: exec: \"iptables\": executable file not found in $PATH [ 0.001] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.run: tun initialization failed: failed to open tun interface (name='', mtu=0): ioctl failed with 'invalid argument' [ 0.001] FATAL ziti/tunnel/cmd/ziti-tunnel/subcmd.run: failed to initialize an interceptor Intercept Modes tproxy tproxy is the preferred intercept mode when running on a Linux kernel that has the ip_tables kernel module installed. $ lsmod | grep ip_tables ip_tables 32768 5 iptable_filter,iptable_security,iptable_raw,iptable_nat,iptable_mangle ziti-tunnel manipulates routing tables and firewall rules when using the tproxy intercept mode. The NET_ADMIN Linux capability is required for these actions. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tproxy [ 0.000] INFO ziti/tunnel/intercept/tproxy.New: tproxy listening on 127.0.0.1:33355 [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.018] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.018] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.033] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.096] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.290] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.300] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.570] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding local.io = 169.254.1.1 to resolver The tproxy intercept mode creates a network listener that accepts connections at a randomly selected port on the loopback interface. Intercepted ziti service traffic directed to the listener by two mechanisms: Firewall Rules (iptables) The TPROXY iptables target is the primary intercept mechanism used by the tproxy intercept mode. The TPROXY target essentially sends packets to a local listener without actually modifying the packet's destination address fields. See https://www.kernel.org/doc/Documentation/networking/tproxy.txt and iptables-extensions(8) for more details on the TPROXY target. First, the tproxy interceptor links a new iptables chain to the PREROUTING chain: $ sudo iptables -nt mangle -L PREROUTING | grep NF-INTERCEPT NF-INTERCEPT all -- 0.0.0.0/0 0.0.0.0/0 Then it creates rules in the new chain for each intercepted service. You can view the tproxy rules in play: $ sudo iptables -nt mangle -L NF-INTERCEPT Chain NF-INTERCEPT (1 references) target prot opt source destination TPROXY tcp -- 0.0.0.0/0 5.9.243.187 /* wttr.in */ tcp dpt:443 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 169.254.1.1 /* ssh-local */ tcp dpt:22 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 TPROXY tcp -- 0.0.0.0/0 1.2.3.4 /* netcat */ tcp dpt:22169 TPROXY redirect 127.0.0.1:33355 mark 0x1/0x1 Packets with a destination address that matches the intercept address of a Ziti service are directed to ziti-tunnel's network listener (127.0.0.1:33355 in the examples above). This effectively enables ziti-tunnel to capture packets that are destined for any address using a single listener (and a single port). NOTE: netfilter rules were considered when implementing ziti-tunnel's tproxy intercept mode. netfilter is a slightly more modern than iptables and has a supported netlink API for manipulating rules without \"shelling out\" to the iptables command line utility. netfilter was ultimately abandoned because netfilter tproxy support requires kernel configuration options ( CONFIG_NFT_TPROXY , CONFIG_NFT_SOCKET ) that are not enabled in the default kernels of many common Linux distributions. Local Routes The TPROXY target is only valid in the PREROUTING iptables chain, which is traversed by incoming packets that were routed to the host over the network. A local route is necessary in order to get locally generated packets to traverse the PREROUTING chain: $ ip route show table local local 1.2.3.4 dev lo proto kernel scope host src 1.2.3.4 local 5.9.243.187 dev lo proto kernel scope host src 5.9.243.187 local 169.254.1.1 dev lo proto kernel scope host src 169.254.1.1 tun The tun intercept mode creates an ephemeral tun interface and configures it with the IP addresses of the services that are being proxied. ziti-tunnel manipulates network interfaces when using the tun intercept mode, which requires the NET_ADMIN Linux capability. The usage example here runs ziti-tunnel with sudo as a simple way to obtain NET_ADMIN: $ sudo ziti-tunnel --identity ziti.json tun [ 0.010] INFO ziti/tunnel/dns.NewDnsServer: starting dns server... [ 2.012] INFO ziti/tunnel/dns.NewDnsServer: dns server running at 127.0.0.1:53 [ 2.012] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding ziti-tunnel.resolver.test = 19.65.28.94 to resolver [ 2.031] INFO ziti/tunnel/dns.(*resolver).RemoveHostname: removing ziti-tunnel.resolver.test from resolver [ 2.089] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service wttr.in [ 2.280] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding wttr.in = 5.9.243.187 to resolver [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service wttr.in not hostable [ 2.282] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service ssh-local [ 2.502] INFO ziti/tunnel/dns.(*resolver).AddHostname: adding myhost.io = 169.254.1.2 to resolver [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service ssh-local not hostable [ 2.505] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: starting tunnel for newly available service netcat [ 2.506] INFO ziti/tunnel/cmd/ziti-tunnel/subcmd.updateServices: service netcat not hostable ... The addresses that ziti-tunnel adds to the tun interface are point-to-point addresses: $ ip addr show dev tun0 10: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 65535 qdisc fq_codel state UNKNOWN group default qlen 500 link/none inet 169.254.1.1/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 5.9.243.187/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 169.254.1.2/32 scope host tun0 valid_lft forever preferred_lft forever inet 169.254.1.1 peer 1.2.3.4/32 scope host tun0 valid_lft forever preferred_lft forever The tun interface itself is assigned a link-local address, 169.254.1.1 in this case, and each intercepted service is represented by a point-to-point address with the remote address matching the intercept IP of the Ziti service. The tun intercept mode uses point-to-point addresses instead of local routes because local routes would result in the Linux networking stack receiving the packets that are routed to the tun interface. The point-to-point addresses ensure that the packets are delivered \"to the wire\", which mean that, for a tun interface, the packets will be picked up by ziti-tunnel when it reads data from the tun interface. proxy The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN DNS Server ziti-tunnel runs an internal DNS server by default. The DNS server must be first in the host's resolver configuration (e.g. resolve.conf). A self-test is performed when ziti-tunnel starts to ensure that its internal DNS server is configured in the system resolver: INFO[0002] dns server started on 127.0.0.1:53 INFO[0002] adding ziti-tunnel.resolver.test -> 19.65.28.94 to resolver INFO[0002] removing ziti-tunnel.resolver.test from resolver The test involves inserting a known hostname/IP address into the internal DNS server, and using the system resolver to retrieve the address of the hostname. ziti-tunnel will exit if the DNS self-test fails. Linux distributions typically manage the contents of /etc/resolv.conf, so simply editing the file will only work for a short time until /etc/resolv.conf is overwritten by the managing process. Resolver configuration changes must survive restarts of the Linux name resolution manager. Linux distrubutions use one of several name resolution managers. The simplest way to determine which name resolution manager is being used by your Linux distrubtion is to look at /etc/resolv.conf: $ ls -l /etc/resolv.conf If /etc/resolv.conf is a regular file, then it is most likely being managed by dhclient . If /etc/resolv.conf is a symlink to a file in /run/systemd/resolve, then it is being managed by systemd-resolved dhclient If your Linux distribution uses dhclient, you can configure the system resolver to use ziti-tunnel's internal DNS server first by adding the following to /etc/dhcp/dhclient.conf: prepend domain-name-servers 127.0.0.1; Then restart network manager. Unless you know the name of the NetworkManager systemd service on your Linux distrubtion, it's probably easiest to reboot the host. systemd-resolved $ sudo ln -sf /run/systemd/resolve/resolv.conf /etc $ echo -e \"[Resolve]\\nDNS=127.0.0.1\" | sudo tee /etc/systemd/resolved.conf.d/ziti-tunnel.conf $ sudo systemctl restart systemd-resolved If you are unable to control the resolver on your operating system, ziti-tunnel can use/update a hosts file for any hostnames that it tunnels: ziti-tunnel run --resolver file:///etc/hosts \"${HOME}/ziti.json\" IP Address Assignment If the service specifies a hostname for its address, ziti-tunnel resolves the hostname and adds the result to its internal DNS server: [0127] INFO adding myservice.mydomain.com -> 45.60.32.165 to resolver If the service hostname does not resolve, ziti-tunnel will find an unused link-local address and assign it to the route for the service: [0012] INFO adding bogushost.net -> 169.254.1.4 to resolver [0012] INFO ziti/tunnel/protocols/tcp.Listen: Accepting on 169.254.1.4:25 service=telnet Windows The Windows tunneler currently supports proxy mode and cannot yet seamlessly intercept IPv4 traffic/DNS requests. The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN Android The Android tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months. iOS The iOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months. MacOS The MacOS tunneler is currently in a closed-beta. NetFoundry will look to open this up to everyone in the coming months."
  },
  "api/clang/index.html": {
    "href": "api/clang/index.html",
    "title": "C Land SDK | NetFoundry Ziti",
    "keywords": "C Land SDK this is the landing page for c"
  },
  "ziti/hello-ziti.html": {
    "href": "ziti/hello-ziti.html",
    "title": "| NetFoundry Ziti",
    "keywords": "If you are seeing this - you have successfully connected to a Ziti network!"
  },
  "ziti/clients/windows.html": {
    "href": "ziti/clients/windows.html",
    "title": "Windows | NetFoundry Ziti",
    "keywords": "Windows The Windows tunneler currently supports proxy mode and cannot yet seamlessly intercept IPv4 traffic/DNS requests. The proxy intercept mode creates a network listener for each Ziti service that is intercepted. The services to intercept, and the ports that they are intercepted on, are specified on the command line (as opposed to using the service definitions that are retrieved from the Ziti Edge Controller): $ ziti-tunnel --identity ziti.json proxy wttr.in:8443 ssh-local:2222 netcat:22169 [ 0.004] INFO ziti/tunnel/intercept/proxy.(*proxyInterceptor).Start: starting proxy interceptor [ 0.120] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service ssh-local [ 0.183] INFO ziti/tunnel/intercept.updateServices: service ssh-local not hostable [ 0.183] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service netcat [ 0.183] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:2222] service=[ssh-local]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: service netcat not hostable [ 0.203] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:22169] service=[netcat]} service is listening [ 0.203] INFO ziti/tunnel/intercept.updateServices: starting tunnel for newly available service wttr.in [ 0.226] INFO ziti/tunnel/intercept.updateServices: service wttr.in not hostable [ 0.226] INFO ziti/tunnel/intercept/proxy.proxyInterceptor.runServiceListener: {addr=[0.0.0.0:8443] service=[wttr.in]} service is listening All network listeners bind to local network interfaces (0.0.0.0): $ netstat -tnl | fgrep 0.0.0.0 Active Internet connections (only servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:22169 0.0.0.0:* LISTEN tcp 0 0 0.0.0.0:8443 0.0.0.0:* LISTEN"
  },
  "api/csharp/NetFoundry.ZitiException.html": {
    "href": "api/csharp/NetFoundry.ZitiException.html",
    "title": "Class ZitiException | NetFoundry Ziti",
    "keywords": "Class ZitiException Represents a Ziti-specific exception Inheritance System.Object ZitiException Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public class ZitiException : Exception Constructors | Improve this Doc ZitiException(String) The basic constructor for creating a ZitiException Declaration public ZitiException(string message) Parameters Type Name Description System.String message The message"
  },
  "api/csharp/NetFoundry.ZitiConnection.OnConnected.html": {
    "href": "api/csharp/NetFoundry.ZitiConnection.OnConnected.html",
    "title": "Delegate ZitiConnection.OnConnected | NetFoundry Ziti",
    "keywords": "Delegate ZitiConnection.OnConnected A delegate that represents the work to be done after a Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) operation. The result of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) may NOT be successful. It is important to verify the result by checking status Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public delegate void OnConnected(ZitiConnection zitiConnection, ZitiStatus status); Parameters Type Name Description ZitiConnection zitiConnection The ZitiConnection which as passed to the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived) method ZitiStatus status The ZitiStatus representing the outcome of the Dial(ZitiConnection.OnConnected, ZitiConnection.OnDataReceived)"
  },
  "api/csharp/NetFoundry.ZitiStatus.html": {
    "href": "api/csharp/NetFoundry.ZitiStatus.html",
    "title": "Enum ZitiStatus | NetFoundry Ziti",
    "keywords": "Enum ZitiStatus An enum representing the outcome of the given Ziti operation. Namespace : NetFoundry Assembly : Ziti.NET.Standard.dll Syntax public enum ZitiStatus : int Fields Name Description CONFIG_NOT_FOUND A user error indicating the provided configuration file was not found. CONNABORT An exceptional situation indicating the connection between the client and the Ziti Network Gateway was interrupted CONTROLLER_UNAVAILABLE A network error indicating the Ziti Network Controller was not able to be contacted. EOF A normal status indicating the connection is closed. GATEWAY_UNAVAILABLE A network error indicating the Ziti Network Gateway was not able to be contacted. NOT_AUTHORIZED A user error indicating the identity from the provided configuration file is not authorized to perform the action. OK Indicates a successful outcome SERVICE_UNAVALABLE A user error indicating the service name provided was not available. Either it does not exist or the provided identity does not have sufficient rights to the service. TIMEOUT An exceptional status indicating the operation did not complete within the specified timeout"
  },
  "api/rest/index.html": {
    "href": "api/rest/index.html",
    "title": "| NetFoundry Ziti",
    "keywords": "this is the landing page for rest"
  },
  "samples/clang.html": {
    "href": "samples/clang.html",
    "title": "| NetFoundry Ziti",
    "keywords": ""
  },
  "ziti/clients/how-to-choose.html": {
    "href": "ziti/clients/how-to-choose.html",
    "title": "Choosing a Ziti Client | NetFoundry Ziti",
    "keywords": "Choosing a Ziti Client After creating a Ziti Network you will quickly find the need for a client that can connect directly to the overlay. There are two types of clients for Ziti Networks: SDK-based and Tunneler-based. Which client is right for you is a relatively straightforward question to answer."
  }
}